<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSRF 使用入门</title>
    <url>/2020/05/01/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/csrf%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>CSRF：需要用户先登录网站 A，获取 cookie。<br>CSRF：是利用网站 A 本身的漏洞，去请求网站 A 的 api。</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS</title>
    <url>/2020/05/01/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/xss%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>XSS：不需要登录。<br>XSS：是向网站 A 注入 JS 代码，然后执行 JS 里的代码，篡改网站 A 的内容。</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>C - 如何使用指针交换变量？</title>
    <url>/2016/05/01/%E5%90%8E%E7%AB%AF/C/C%20-%20%E6%8C%87%E9%92%88%E4%BA%A4%E6%8D%A2%E5%8F%98%E9%87%8F%EF%BC%9F/</url>
    <content><![CDATA[<p>交换变量，使用指针处理；</p>
<p>代码示范：</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">float</span> *y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">float</span> y = <span class="number">10.0001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针交换变量</span></span><br><span class="line">    swap(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输出结果： %d %le \n&quot;</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *x, <span class="type">float</span> *y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2016/05/01/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://lsj162.gitbook.io/suan-fa-xue-xi-bi-ji/">迁移到 GITBOOK</a></p>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>🎉 C 诞生史</title>
    <url>/2014/05/01/%E5%90%8E%E7%AB%AF/C/C%20%E8%AF%9E%E7%94%9F%E5%8F%B2/</url>
    <content><![CDATA[<p><img src="/images/w3c.png"></p>
<p>🪴</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>20 世纪 70 年代，肯·汤姆森为了使其设计的 Unix 系统更加高效，使用 B 语言的变种（即 C 语言）在 DEC PDP-7 计算机上重写了 Unix。C 语言中许多重要概念来源于 BCPL 语言，其对 C 语言的影响也间接地来源于 B 语言。</p>
<p>在 1978 年，丹尼斯·里奇和布莱恩·柯林汉合作出版了《C 程序设计语言》第一版，事实上即为 K&amp;R C 标准[5]。1983 年，为了制定一个独立于具体机器且无歧义的 C 语言标准，美国国家标准协会成立了一个委员会，并在 1988 年完成了该标准的制定，即 ANSI C。此标准同时被国际标准化组织所采纳，也被称作 ISO C。</p>
<p>其后，C 语言至今经历了几次标准更新，诞生了 C99、C11 和目前最新的标准 C18。C 语言标准的下一次更新 C2x 目前正在起草中。</p>
<h2 id="早期发展"><a href="#早期发展" class="headerlink" title="早期发展"></a>早期发展</h2><p>第一次发展在 1969 年到 1973 年之间。</p>
<p>1970 年，肯·汤普逊为运行在 PDP-7 上的首个 Unix 系统设计了一个精简版的 BCPL，这个语言被称为 B 语言，它也是无类型的。</p>
<p>C 语言最早由丹尼斯·里奇（Dennis Ritchie）为了在 PDP-11 电脑上运行的 Unix 系统所设计出来的程式语言，后者由马丁·理察德（Martin Richards）于 1967 年左右设计实现。</p>
<p>1973 年，Unix 作业系统的核心正式用 C 语言改写，这是 C 语言第一次应用在作业系统的核心编写上。</p>
<p>1975 年，C 语言开始移植到其他机器上使用。史蒂芬·强生实现了一套“可移植编译器”，这套编译器修改起来相对容易，并且可以为不同的机器生成代码。从那时起，C 在大多数计算机上被使用，从最小的微型计算机到与 CRAY-2 超级计算机。</p>
<p>1978 年，丹尼斯·里奇和布莱恩·柯林汉合作出版了《C 程序设计语言》的第一版。</p>
<p>1989 年，C 语言被美国国家标准协会（ANSI）标准化，编号为 ANSI X3.159-1989。这个版本又称为 C89。</p>
<p>1990 年，国际标准化组织（ISO）成立 ISO&#x2F;IEC JTC1&#x2F;SC22&#x2F;WG14 工作组，来规定国际标准的 C 语言，通过对 ANSI 标准的少量修改，最终制定了 ISO 9899:1990，又称为 C90。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zh.wikipedia.org/zh-hans/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8E%86%E5%8F%B2">https://zh.wikipedia.org/zh-hans/C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8E%86%E5%8F%B2</a></p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>🎉 Go 诞生史</title>
    <url>/2014/05/01/%E5%90%8E%E7%AB%AF/Go/Go%20%E8%AF%9E%E7%94%9F%E5%8F%B2/</url>
    <content><![CDATA[<p><img src="/images/w3c.png"></p>
<p>🪴</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>Go（又称 Golang）是 Google 开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。目的在于提高在多核、网络机器（networked machines）、大型代码库（codeBases）的情况下的开发效率。</p>
<p>2007 年 09 月，Google 设计 Go，由罗伯特·格瑞史莫、罗勃·派克及肯·汤普逊开始设计，稍后伊恩·兰斯·泰勒（Ian Lance Taylor）、拉斯·考克斯（Russ Cox）加入专案。Go 是基于 Inferno 作业系统所开发的。</p>
<p>2009 年 11 月，正式宣布推出 Go，成为开放原始码专案，支援 Linux、macOS、Windows 等作业系统。</p>
<p>2012 年 03 月，发布版本 1.0。</p>
<p>2018 年 08 月，Go 的主要贡献者发布了两个关于语言新功能的“草稿设计——泛型和异常处理</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zh.wikipedia.org/wiki/Go">https://zh.wikipedia.org/wiki/Go</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>🎉 Java 诞生史</title>
    <url>/2014/05/01/%E5%90%8E%E7%AB%AF/Java/Java%20%E8%AF%9E%E7%94%9F%E5%8F%B2/</url>
    <content><![CDATA[<p><img src="/images/w3c.png"></p>
<p>🪴</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>1990 年 12 月，语言最开始只是 Sun 微系统（Sun MicroSystems）公司在研究的一个内部项目。</p>
<p>1995 年 05 月，Java 语言诞生。</p>
<p>2005 年 06 月，JavaOne 大会召开，Sun 微系统公开 Java SE 6。此时，Java 的各种版本已经更名，以取消其中的数字“2”：J2EE 更名为 Java EE，J2SE 更名为 Java SE，J2ME 更名为 Java ME</p>
<p>2006 年 12 月，Sun 微系统在 JavaOne 公布 Java 开放源代码项目，并推出 OpenJDK 计划。Java 虚拟机、Java 编译器和 Java 类库以 GNU 通用公共许可证公开。</p>
<p>2022 年 09 月，Oracle 公司发布 Java SE 19。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zh.wikipedia.org/wiki/Java#%E5%8E%86%E5%8F%B2">https://zh.wikipedia.org/wiki/Java#%E5%8E%86%E5%8F%B2</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>🎉 Mongo 诞生史</title>
    <url>/2014/05/01/%E5%90%8E%E7%AB%AF/Mongo/Mongo%20%E8%AF%9E%E7%94%9F%E5%8F%B2/</url>
    <content><![CDATA[<p><img src="/images/w3c.png"></p>
<p>🪴</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>2007 年 10 月，Dwight、Eliot 和 Kevin Ryan 创办了一家名为 10gen 的新公司。当时是 10gen 团队开发。</p>
<p>2009 年 02 月，首度推出，现以服务器端公共许可（SSPL）分发。</p>
<p>2016 年，MongoDB 推出了 Atlas 服务。</p>
<p>2017 年，MongoDB 推出后端服务 Stitch。</p>
<p>2018 年，发布了 MongoDB4.0。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zh.wikipedia.org/wiki/MongoDB">https://zh.wikipedia.org/wiki/MongoDB</a><br><a href="https://www.quickprogrammingtips.com/mongodb/mongodb-history.html">https://www.quickprogrammingtips.com/mongodb/mongodb-history.html</a></p>
]]></content>
      <categories>
        <category>Mongo</category>
      </categories>
      <tags>
        <tag>Mongo</tag>
      </tags>
  </entry>
  <entry>
    <title>🎉 Mysql 诞生史</title>
    <url>/2014/05/01/%E5%90%8E%E7%AB%AF/Mysql/Mysql%20%E8%AF%9E%E7%94%9F%E5%8F%B2/</url>
    <content><![CDATA[<p><img src="/images/w3c.png"></p>
<p>🪴</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>MySQL 是一个开源的关系数据库管理系统，数据存放在表中。最初开发者为瑞典的 MySQL AB 公司，</p>
<p>1994 年，MySQL 的最初由 Widenius 和 Axmark 开始开发。</p>
<p>1995 年 5 月 23 日，MySQL 发布第一个版本。</p>
<p>2008 年，被升阳微系统收购。</p>
<p>2009 年，甲骨文公司收购升阳微系统公司，MySQL 成为 Oracle 旗下产品。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/MySQL">https://en.wikipedia.org/wiki/MySQL</a></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 上传文件大小限制</title>
    <url>/2020/01/01/%E5%90%8E%E7%AB%AF/Nginx/2.%20Nginx%20%E9%85%8D%E7%BD%AE%E4%B9%8B%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<h1 id="如果您需要上传限制-100MB-那么："><a href="#如果您需要上传限制-100MB-那么：" class="headerlink" title="如果您需要上传限制 100MB 那么："></a>如果您需要上传限制 100MB 那么：</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localion / &#123;</span><br><span class="line">    # 将客户端主体大小设置为 100 MB</span><br><span class="line">    client_max_body_size 100M;</span><br><span class="line"></span><br><span class="line">    # ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>🎉 Redis 诞生史</title>
    <url>/2014/05/01/%E5%90%8E%E7%AB%AF/Redis/Redis%20%E8%AF%9E%E7%94%9F%E5%8F%B2/</url>
    <content><![CDATA[<p><img src="/images/w3c.png"></p>
<p>🪴</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>Redis 这个名字的意思是远程字典服务器。 Redis 项目始于 Salvatore Sanfilippo（昵称 antirez），他是 Redis 的原始开发人员，当时他正试图提高其意大利初创公司的可扩展性，开发实时 Web 日志分析器。</p>
<p>2009 年 12 月，Sanfilippo 开始在 Tcl 中构建 Redis 的第一个概念验证版本的原型。</p>
<p>2010 年 03 月，Sanfilippo 于 被 VMware 聘用。</p>
<p>2013 年 5 月，Redis 得到了 Pivotal Software（VMware 的衍生公司）的赞助。</p>
<p>2015 年 6 月， Redis Labs 赞助了开发。</p>
<p>2018 年 10 月，Redis 5.0 发布。</p>
<p>2020 年 06 月，Salvatore Sanfilippo 辞去了 Redis 维护者的职务。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/Redis">https://en.wikipedia.org/wiki/Redis</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 响应状态码</title>
    <url>/2014/05/01/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/HTTP%20%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<p><img src="/images/w3c.png"></p>
<h2 id="HTTP-响应状态码用来表明特定-HTTP-请求是否成功完成。-响应被归为以下五大类："><a href="#HTTP-响应状态码用来表明特定-HTTP-请求是否成功完成。-响应被归为以下五大类：" class="headerlink" title="HTTP 响应状态码用来表明特定 HTTP 请求是否成功完成。 响应被归为以下五大类："></a>HTTP 响应状态码用来表明特定 HTTP 请求是否成功完成。 响应被归为以下五大类：</h2><ul>
<li>信息响应 (100–199)</li>
<li>成功响应 (200–299)</li>
<li>重定向消息 (300–399)</li>
<li>客户端错误响应 (400–499)</li>
<li>服务端错误响应 (500–599)</li>
</ul>
<span id="more"></span>

<h2 id="信息响应"><a href="#信息响应" class="headerlink" title="信息响应"></a>信息响应</h2><p>‘100’: ‘Continue’,<br>‘101’: ‘Switching Protocols’,<br>‘102’: ‘Processing’, # 此代码表示服务器已收到并正在处理该请求，但当前没有响应可用。<br>‘103’: ‘Early Hints’,</p>
<h2 id="成功响应"><a href="#成功响应" class="headerlink" title="成功响应"></a>成功响应</h2><p>‘200’: ‘OK’, # 请求成功。<br>‘201’: ‘Created’, # 该请求已成功，并因此创建了一个新的资源。这通常是在 POST 请求，或是某些 PUT 请求之后返回的响应。<br>‘202’: ‘Accepted’,<br>‘203’: ‘Non-Authoritative Information’,<br>‘204’: ‘No Content’, # 对于该请求没有的内容可发送，但头部字段可能有用。<br>‘205’: ‘Reset Content’,<br>‘206’: ‘Partial Content’, # 当从客户端发送 Range 范围标头以只请求资源的一部分时，将使用此响应代码。<br>‘207’: ‘Multi-Status’,<br>‘208’: ‘Already Reported’,<br>‘226’: ‘IM Used’,</p>
<h2 id="重定向消息"><a href="#重定向消息" class="headerlink" title="重定向消息"></a>重定向消息</h2><p>‘300’: ‘Multiple Choices’,<br>‘301’: ‘Moved Permanently’, # 请求资源的 URL 已永久更改。在响应中给出了新的 URL。<br>‘302’: ‘Found’, # 临时性重定向。与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI<br>‘303’: ‘See Other’,<br>‘304’: ‘Not Modified’, # 这是用于缓存的目的。它告诉客户端响应还没有被修改，因此客户端可以继续使用相同的缓存版本的响应。<br>‘305’: ‘Use Proxy’,<br>‘307’: ‘Temporary Redirect’, # 临时重定向。与 302 类似。<br>‘308’: ‘Permanent Redirect’,</p>
<h2 id="客户端错误响应"><a href="#客户端错误响应" class="headerlink" title="客户端错误响应"></a>客户端错误响应</h2><p>‘400’: ‘Bad Request’, # 由于被认为是客户端错误，服务器无法或不会处理请求。<br>‘401’: ‘Unauthorized’, # 客户端必须对自身进行身份验证才能获得请求的响应。<br>‘402’: ‘Payment Required’,<br>‘403’: ‘Forbidden’, # 客户端没有访问内容的权限；也就是说，它是未经授权的，因此服务器拒绝提供请求的资源。与 401 不同，服务器知道客户端的身份。<br>‘404’: ‘Not Found’, # 服务器找不到请求的资源。<br>‘405’: ‘Method Not Allowed’, # 服务器知道请求方法，但目标资源不支持该方法。<br>‘406’: ‘Not Acceptable’,<br>‘407’: ‘Proxy Authentication Required’,<br>‘408’: ‘Request Timeout’,<br>‘409’: ‘Conflict’,<br>‘410’: ‘Gone’,<br>‘411’: ‘Length Required’,<br>‘412’: ‘Precondition Failed’,<br>‘413’: ‘Payload Too Large’,<br>‘414’: ‘URI Too Long’,<br>‘415’: ‘Unsupported Media Type’,<br>‘416’: ‘Range Not Satisfiable’,<br>‘417’: ‘Expectation Failed’,<br>‘418’: “I’m a Teapot”,<br>‘421’: ‘Misdirected Request’,<br>‘422’: ‘Unprocessable Entity’,<br>‘423’: ‘Locked’,<br>‘424’: ‘Failed Dependency’,<br>‘425’: ‘Too Early’,<br>‘426’: ‘Upgrade Required’,<br>‘428’: ‘Precondition Required’,<br>‘429’: ‘Too Many Requests’,<br>‘431’: ‘Request Header Fields Too Large’,<br>‘451’: ‘Unavailable For Legal Reasons’,</p>
<h2 id="服务端错误响应"><a href="#服务端错误响应" class="headerlink" title="服务端错误响应"></a>服务端错误响应</h2><p>‘500’: ‘Internal Server Error’, # 服务器遇到了不知道如何处理的情况。<br>‘501’: ‘Not Implemented’, # 服务器不支持请求方法，因此无法处理。<br>‘502’: ‘Bad Gateway’, # 服务器网关处理这个请求，返回一个错误的响应。<br>‘503’: ‘Service Unavailable’, # 服务器没有准备好处理请求。<br>‘504’: ‘Gateway Timeout’, # 当服务器充当网关且无法及时获得响应时，会给出此错误响应。<br>‘505’: ‘HTTP Version Not Supported’,<br>‘506’: ‘Variant Also Negotiates’,<br>‘507’: ‘Insufficient Storage’,<br>‘508’: ‘Loop Detected’,<br>‘509’: ‘Bandwidth Limit Exceeded’,<br>‘510’: ‘Not Extended’,<br>‘511’: ‘Network Authentication Required’</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a><br><a href="https://www.rfc-editor.org/">https://www.rfc-editor.org/</a><br><a href="https://datatracker.ietf.org/doc/html/rfc2616#section-10">https://datatracker.ietf.org/doc/html/rfc2616#section-10</a></p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>🎉 Rust 诞生史</title>
    <url>/2014/05/01/%E5%90%8E%E7%AB%AF/Rust/Rust%20%E8%AF%9E%E7%94%9F%E5%8F%B2/</url>
    <content><![CDATA[<p><img src="/images/w3c.png"></p>
<p>🪴</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>2006 年，Rust 源于 Mozilla Research 员工 Graydon Hoare 启动的个人项目。</p>
<p>2009 年，Mozilla 开始赞助该项目。</p>
<p>2010 年，该引擎由 Mozilla 正式宣布。</p>
<p>2011 年，Rust 编译器成功编译了自己。</p>
<p>2015 年 5 月 15 日发布。第一个稳定版本 Rust 1.0。</p>
<p>2021 年 2 月 8 日，Rust 基金会的五家创始公司（ AWS、华为、谷歌、微软和 Mozilla）宣布成立。</p>
<p>2021 年 11 月 22 日，负责执行社区标准和行为准则的审核团队宣布辞职。</p>
<p>2023 年 4 月 6 日，Rust 基金会发布了新商标政策草案，修改了 Rust 徽标和名称的使用规则，这引起了 Rust 用户和贡献者的负面反应。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/Rust_(programming_language)">https://en.wikipedia.org/wiki/Rust_(programming_language)</a></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Css - 概念？</title>
    <url>/2014/05/01/%E5%89%8D%E7%AB%AF/CSS/Css%20-%20%E6%A6%82%E5%BF%B5%EF%BC%9F/</url>
    <content><![CDATA[<!-- # CSS 是什么？ -->

<p>CSS 即层叠样式表（Cascading Style Sheets），是一种用来表现 HTML 或 XML 等文件样式的计算机语言。CSS 不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。</p>
<p>CSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。</p>
<span id="more"></span>

<ol>
<li><p>CSS 选择器有哪些？优先级排序？哪些属性可以继承？<br>答案：<br>id 选择器(#myid)、类选择器(.myclassname)、标签选择器(div, h1, p)、相邻选择器(h1 + p)、子选择器（ul &gt; li）、后代选择器（li a）、通配符选择器（*）、属性选择器（a[rel&#x3D;”external”]）、伪类选择器（a:hover, li:nth-child）</p>
<pre><code>可继承的属性：font-size, font-family, color
不可继承的样式：border, padding, margin, width, height
</code></pre>
</li>
<li><p>如何居中 div？如何居中一个浮动元素？如何让绝对定位的 div 居中？</p>
</li>
<li><p>display 属性常见的有哪些值？<br>block 块显示<br>inline-block 行内块显示<br>none 隐藏</p>
</li>
<li><p>position 的值？<br>static（默认）：按照正常 文档流 进行排列；<br>relative（相对定位）：不脱离文档流，参考自身静态位置通过 top, bottom, left, right 定位；<br>absolute(绝对定位)：参考距其最近一个不为 static 的父级元素通过 top, bottom, left, right 定位；<br>fixed(固定定位)：所固定的参照对像是可视窗口。</p>
</li>
<li><p>CSS3 有哪些新特性？<br>RGBA 和透明度<br>background-image background-origin(content-box&#x2F;padding-box&#x2F;border-box) background-size background-repeat<br>word-wrap（对长的不可分割单词换行）word-wrap：break-word<br>文字阴影：text-shadow： 5px 5px 5px #FF0000;（水平阴影，垂直阴影，模糊距离，阴影颜色）<br>font-face 属性：定义自己的字体<br>圆角（边框半径）：border-radius 属性用于创建圆角<br>边框图片：border-image: url(border.png) 30 30 round<br>盒阴影：box-shadow: 10px 10px 5px #888888<br>媒体查询：定义两套 css，当浏览器的尺寸变化时会采用不同的属性</p>
</li>
<li><p>请解释一下 CSS3 的 flexbox（弹性盒布局模型）,以及适用场景？</p>
<p>该布局模型的目的是提供一种更加高效的方式来对容器中的条目进行布局、对齐和分配空间。在传统的布局方式中，block 布局是把块在垂直方向从上到下依次排列的；而 inline 布局则是在水平方向来排列。弹性盒布局并没有这样内在的方向限制，可以由开发人员自由操作。<br>试用场景：弹性布局适合于移动前端开发，在 Android 和 ios 上也完美支持。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS - Proxy 与 Object.defineProperty 优劣对比？</title>
    <url>/2014/05/01/%E5%89%8D%E7%AB%AF/JavaScript/JS%20-%20Proxy%20%E4%B8%8E%20Object.defineProperty%20%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="Proxy-的优势如下"><a href="#Proxy-的优势如下" class="headerlink" title="Proxy 的优势如下:"></a>Proxy 的优势如下:</h2><p>Proxy 可以直接监听对象而非属性；</p>
<p>Proxy 可以直接监听数组的变化；</p>
<p>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.<br>defineProperty 不具备的；</p>
<span id="more"></span>

<p>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</p>
<p>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</p>
<h2 id="Object-defineProperty-的优势如下"><a href="#Object-defineProperty-的优势如下" class="headerlink" title="Object.defineProperty 的优势如下:"></a>Object.defineProperty 的优势如下:</h2><p>兼容性好，支持 IE9，而 Proxy 不兼容性 IE,而且无法用 polyfill 磨平;</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>hash 路由 与 history 路由有什么区别？</title>
    <url>/2014/05/01/%E5%89%8D%E7%AB%AF/JavaScript/JS%20-%20hash%20%E8%B7%AF%E7%94%B1%20%E4%B8%8E%20history%20%E8%B7%AF%E7%94%B1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%F0%9F%94%A5%F0%9F%94%A5/</url>
    <content><![CDATA[<!-- # hash 路由 与 history 路由有什么区别？ -->

<ul>
<li><p>区别：<br>URL 格式的不同。</p>
<p>实现简单、兼容性好，而且可以运行在大多数 Web 服务器上；缺点在于 URL 不够美观，不利于搜索引擎优化（SEO）。</p>
</li>
</ul>
<span id="more"></span>

<pre><code>History 路由解决了美观，SEO 的问题
</code></pre>
<ul>
<li>实现原理：<br>html5 机制</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS - 什么作用域和闭包？</title>
    <url>/2014/05/01/%E5%89%8D%E7%AB%AF/JavaScript/JS%20-%20%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85%EF%BC%9F/</url>
    <content><![CDATA[<!-- # 什么作用域和闭包？ -->

<ul>
<li>作用域<br>JavaScript 采用词法作用域（Lexical Scope）即静态作用域，函数的作用域在函数定义时就已经确定，不会受调用位置的影响。在 JavaScript 中，<code>全局作用域</code>和<code>函数作用域</code>都是词法作用域，也就是说函数可以访问其内部外部的变量，但是外部无法访问函数内部的变量。</li>
</ul>
<span id="more"></span>

<ul>
<li>闭包<br>闭包（Closure）是指函数可以访问并操作其外部作用域的变量，即使外部作用域已经销毁，也不会影响函数内部对这些变量的访问。<br>所以闭包也可以看做是函数对其外部作用域的引用，通过这种方式扩展了函数的作用域链。</li>
</ul>
<h1 id="产生的内存泄露"><a href="#产生的内存泄露" class="headerlink" title="产生的内存泄露"></a>产生的内存泄露</h1><p>或者使用 WeakMap 来实现自动化的垃圾回收。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createClosure</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        <span class="comment">/*...*/</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 obj ...</span></span><br><span class="line">        obj = <span class="literal">null</span>; <span class="comment">// 将 obj 置为 null</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> closure = <span class="title function_">createClosure</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">closure</span>(); <span class="comment">// 执行内部函数，此时 obj 对象已被置为 null，可以被垃圾回收机制回收</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS - 什么是高阶函数？</title>
    <url>/2014/05/01/%E5%89%8D%E7%AB%AF/JavaScript/JS%20-%20%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%EF%BC%9F/</url>
    <content><![CDATA[<!-- # JS - 什么是高阶函数？ -->

<p>高阶函数是接受一个或多个函数作为参数或返回一个函数的函数。</p>
<p>在 JavaScript 中，可以使用高阶函数实现许多常见的编程模式，如映射、过滤、排序和归约。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS - 数据类型?</title>
    <url>/2014/05/01/%E5%89%8D%E7%AB%AF/JavaScript/JS%20-%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B?/</url>
    <content><![CDATA[<!-- # JS - 数据类型? -->

<ul>
<li>基本数据类型<br>数字（Number）：表示数值。例如：42，3.14。<br>字符串（String）：表示文本数据。例如：”Hello”，’World’。<br>布尔值（Boolean）：表示真（true）或假（false）值。<br>undefined：表示未定义的值。<br>null：表示空值。<br>BigInt：用于表示大整数，超出了 JavaScript 中 Number 类型的范围。例如：1000000000000000000001。<br>Symbol：表示唯一的标识符。Symbol 类型的值是通过 Symbol() 函数创建的。例如：const id &#x3D; Symbol(‘id’)。</li>
</ul>
<span id="more"></span>

<ul>
<li>复杂数据类型<br>对象（Object）：对象是键值对的集合，用于存储相关数据和功能。例如：let person &#x3D; { name: “John”, age: 30 };。<br>数组（Array）：数组是有序的值列表，用于存储多个值。例如：let numbers &#x3D; [1, 2, 3, 4];。<br>函数（Function）：函数是一段可重复使用的代码块，用于执行特定任务。例如：function add(a, b) { return a + b; }。</li>
</ul>
<h1 id="识别"><a href="#识别" class="headerlink" title="识别"></a>识别</h1><pre><code>typeof 操作符：typeof 操作符返回一个字符串，表示操作数的数据类型。

例如：typeof 42 返回 &quot;number&quot;，typeof &quot;Hello&quot; 返回 &quot;string&quot;，typeof true 返回 &quot;boolean&quot;。

instanceof 操作符：instanceof 操作符用于检查对象是否属于特定类型。它通过比较对象的原型链来确定对象是否是给定类型的实例。

例如：let arr = [1, 2, 3]; arr instanceof Array 返回 true，let obj = &#123;&#125;; obj instanceof Object 返回 true。

Array.isArray() 函数：Array.isArray() 函数用于检查一个值是否为数组。它返回一个布尔值，表示该值是否为数组类型。

例如：Array.isArray([1, 2, 3]) 返回 true，Array.isArray(&quot;Hello&quot;) 返回 false。

Object.prototype.toString.call() 方法：这种方法可以用于检测任何数据类型。通过调用 Object.prototype.toString.call() 并传入要检测的值作为参数，它会返回一个表示该值的具体类型的字符串。

例如：Object.prototype.toString.call(42) 返回 [object Number]，Object.prototype.toString.call(&quot;Hello&quot;) 返回 [object String]。
</code></pre>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS - 概念？</title>
    <url>/2014/05/01/%E5%89%8D%E7%AB%AF/JavaScript/JS%20-%20%E6%A6%82%E5%BF%B5%EF%BC%9F/</url>
    <content><![CDATA[<!-- - JS - 概念？ -->

<h2 id="什么是柯里化（Currying）？如何使用它？"><a href="#什么是柯里化（Currying）？如何使用它？" class="headerlink" title="什么是柯里化（Currying）？如何使用它？"></a>什么是柯里化（Currying）？如何使用它？</h2><p>柯里化（Currying）是一种将接受多个参数的函数转换为接受单个参数的函数序列的技术。使用柯里化可以更轻松地创建可重用的函数，并更容易地进行部分应用和组合。</p>
<h2 id="如何使用函数式编程？它的优点和缺点是什么？"><a href="#如何使用函数式编程？它的优点和缺点是什么？" class="headerlink" title="如何使用函数式编程？它的优点和缺点是什么？"></a>如何使用函数式编程？它的优点和缺点是什么？</h2><p>函数式编程是一种编程范式，它强调使用纯函数和不可变数据结构来避免副作用和共享状态。它的优点包括简洁、可读性好、易于测试和并行化。缺点是在某些情况下可能会导致复杂性增加，而且需要更多的内存空间。</p>
<span id="more"></span>

<h2 id="如何使用函数组合（Function-Composition）？有哪些常见的组合函数？"><a href="#如何使用函数组合（Function-Composition）？有哪些常见的组合函数？" class="headerlink" title="如何使用函数组合（Function Composition）？有哪些常见的组合函数？"></a>如何使用函数组合（Function Composition）？有哪些常见的组合函数？</h2><p>函数组合（Function Composition）是将多个函数组合成一个更大的函数的过程。在 JavaScript 中，可以使用函数组合来创建一系列可重用的管道函数。常见的组合函数包括 compose、pipe 和 curry。</p>
<h2 id="什么是-JavaScript-中的变量提升（Hoisting）？如何避免它？"><a href="#什么是-JavaScript-中的变量提升（Hoisting）？如何避免它？" class="headerlink" title="什么是 JavaScript 中的变量提升（Hoisting）？如何避免它？"></a>什么是 JavaScript 中的变量提升（Hoisting）？如何避免它？</h2><p>变量提升指的是在 JavaScript 中，变量和函数声明会被提升到它们所在作用域的顶部，即在代码执行之前就已经进行了声明。为避免变量提升带来的问题，可以使用 let 或 const 关键字声明变量，并使用函数表达式而非函数声明来定义函数。</p>
<h2 id="什么是纯函数（Pure-Function）？为什么要使用它们？"><a href="#什么是纯函数（Pure-Function）？为什么要使用它们？" class="headerlink" title="什么是纯函数（Pure Function）？为什么要使用它们？"></a>什么是纯函数（Pure Function）？为什么要使用它们？</h2><p>纯函数指的是没有副作用且返回值仅由输入决定的函数，即同样的输入总会得到同样的输出，且不会对外部环境产生任何影响。使用纯函数可以提高代码的可读性、可维护性和可测试性，因为它们具有确定性且不会引入意外的行为。</p>
<h2 id="什么是不可变性（Immutability）？如何使用它来编写更健壮的代码？"><a href="#什么是不可变性（Immutability）？如何使用它来编写更健壮的代码？" class="headerlink" title="什么是不可变性（Immutability）？如何使用它来编写更健壮的代码？"></a>什么是不可变性（Immutability）？如何使用它来编写更健壮的代码？</h2><p>不可变性指的是数据一旦被创建后便不能被更改的特性。在 JavaScript 中可以使用 Object.freeze() 方法来冻结对象，或使用第三方库如 Immutable.js 来创建不可变数据。使用不可变性可以避免数据被意外修改，从而减少错误和提高代码健壮性。</p>
<h2 id="什么是-JavaScript-中的事件委托（Event-Delegation）？如何使用它？"><a href="#什么是-JavaScript-中的事件委托（Event-Delegation）？如何使用它？" class="headerlink" title="什么是 JavaScript 中的事件委托（Event Delegation）？如何使用它？"></a>什么是 JavaScript 中的事件委托（Event Delegation）？如何使用它？</h2><p>事件委托是指将事件处理程序绑定到其祖先元素上，从而利用事件冒泡机制来处理子元素的事件。通过事件委托可以减少事件处理程序的数量，提高性能并避免内存泄漏问题。</p>
<h2 id="什么是-JavaScript-中的内存泄漏？如何避免它？"><a href="#什么是-JavaScript-中的内存泄漏？如何避免它？" class="headerlink" title="什么是 JavaScript 中的内存泄漏？如何避免它？"></a>什么是 JavaScript 中的内存泄漏？如何避免它？</h2><p>内存泄漏指的是程序中存在指向已不再使用的内存空间的引用，从而导致这些空间无法被垃圾回收机制释放。为避免内存泄漏，可以手动解除对对象的引用、使用闭包时注意及时释放内存、避免过度使用全局变量等。</p>
<h2 id="什么是尾递归优化？如何使用它？"><a href="#什么是尾递归优化？如何使用它？" class="headerlink" title="什么是尾递归优化？如何使用它？"></a>什么是尾递归优化？如何使用它？</h2><p>尾递归优化是一种优化技术，可以减少递归函数的内存消耗。在 JavaScript 中，可以使用尾递归优化来减少递归函数的栈帧，从而避免堆栈溢出错误。</p>
<h2 id="什么是-JavaScript-中的垃圾回收机制？如何影响应用程序的性能？"><a href="#什么是-JavaScript-中的垃圾回收机制？如何影响应用程序的性能？" class="headerlink" title="什么是 JavaScript 中的垃圾回收机制？如何影响应用程序的性能？"></a>什么是 JavaScript 中的垃圾回收机制？如何影响应用程序的性能？</h2><p>JavaScript 中的垃圾回收机制是通过检测不再使用的变量和对象并释放它们占用的内存空间来实现的。垃圾回收机制的性能会受到代码中对象创建和销毁的频率、变量的作用域以及循环引用等因素的影响。</p>
<h2 id="什么是-JavaScript-中的事件驱动编程（Event-Driven-Programming）？如何使用它？"><a href="#什么是-JavaScript-中的事件驱动编程（Event-Driven-Programming）？如何使用它？" class="headerlink" title="什么是 JavaScript 中的事件驱动编程（Event-Driven Programming）？如何使用它？"></a>什么是 JavaScript 中的事件驱动编程（Event-Driven Programming）？如何使用它？</h2><p>事件驱动编程是一种编程范式，其中程序的执行流程由外部事件触发而不是指令顺序决定。在 JavaScript 中，例如使用事件监听器函数来处理用户交互、浏览器加载等事件。可以通过添加事件监听器（EventListener）来注册事件，监听器函数会在事件被触发时自动运行。</p>
<h2 id="什么是-JavaScript-中的元编程（Metaprogramming）？如何使用它？"><a href="#什么是-JavaScript-中的元编程（Metaprogramming）？如何使用它？" class="headerlink" title="什么是 JavaScript 中的元编程（Metaprogramming）？如何使用它？"></a>什么是 JavaScript 中的元编程（Metaprogramming）？如何使用它？</h2><p>元编程是一种编程技术，其中程序可以修改或生成其他程序。在 JavaScript 中，可以使用原型链、Reflect API、Proxy 对象等元编程技术来修改对象行为、拦截属性操作、创建类等。</p>
<h2 id="什么是-JavaScript-中的数据结构和算法？如何使用它们来解决问题？"><a href="#什么是-JavaScript-中的数据结构和算法？如何使用它们来解决问题？" class="headerlink" title="什么是 JavaScript 中的数据结构和算法？如何使用它们来解决问题？"></a>什么是 JavaScript 中的数据结构和算法？如何使用它们来解决问题？</h2><p>数据结构和算法是计算机科学的核心概念，可以用来解决各种问题。在 JavaScript 中，可以使用内置数据结构（如数组、对象、Map、Set）以及第三方库（如 lodash）来实现常见的数据结构和算法。</p>
<h2 id="什么是-JavaScript-中的单元测试（Unit-Testing）？如何编写和运行单元测试？"><a href="#什么是-JavaScript-中的单元测试（Unit-Testing）？如何编写和运行单元测试？" class="headerlink" title="什么是 JavaScript 中的单元测试（Unit Testing）？如何编写和运行单元测试？"></a>什么是 JavaScript 中的单元测试（Unit Testing）？如何编写和运行单元测试？</h2><p>单元测试是针对程序中最小可测试单元进行的自动化测试。在 JavaScript 中，可以使用测试框架（如 Jest、Mocha）和断言库（如 Chai、Assert）来编写和运行单元测试。</p>
<h2 id="什么是-JavaScript-中的设计模式（Design-Patterns）？如何使用它们来构建可维护的应用程序？"><a href="#什么是-JavaScript-中的设计模式（Design-Patterns）？如何使用它们来构建可维护的应用程序？" class="headerlink" title="什么是 JavaScript 中的设计模式（Design Patterns）？如何使用它们来构建可维护的应用程序？"></a>什么是 JavaScript 中的设计模式（Design Patterns）？如何使用它们来构建可维护的应用程序？</h2><p>设计模式是通用解决问题的经验总结，可以用于构建可维护、可扩展的应用程序。在 JavaScript 中，可以使用常见的设计模式（如观察者模式、工厂模式、单例模式）来解决特定的问题。</p>
<h2 id="什么是-JavaScript-中的重构（Refactoring）？为什么要进行重构？"><a href="#什么是-JavaScript-中的重构（Refactoring）？为什么要进行重构？" class="headerlink" title="什么是 JavaScript 中的重构（Refactoring）？为什么要进行重构？"></a>什么是 JavaScript 中的重构（Refactoring）？为什么要进行重构？</h2><p>重构是改善现有代码设计的过程，旨在提高代码可读性、可维护性和性能。在 JavaScript 中，可以使用重构方法（如拆分函数、提前返回等）来改进代码质量。</p>
<h2 id="如何使用-JavaScript-中的面向对象编程（OOP）？它的优点和缺点是什么？"><a href="#如何使用-JavaScript-中的面向对象编程（OOP）？它的优点和缺点是什么？" class="headerlink" title="如何使用 JavaScript 中的面向对象编程（OOP）？它的优点和缺点是什么？"></a>如何使用 JavaScript 中的面向对象编程（OOP）？它的优点和缺点是什么？</h2><p>面向对象编程是一种基于类和对象的编程方法，JavaScript 中可以使用 class 关键字创建类，使用 new 运算符实例化对象。面向对象编程的优点包括代码架构清晰，易于维护和扩展，缺点包括性能较低，可能过于复杂等。</p>
<h2 id="如何使用-JavaScript-中的正则表达式（Regular-Expression）？有哪些常见的正则表达式模式？"><a href="#如何使用-JavaScript-中的正则表达式（Regular-Expression）？有哪些常见的正则表达式模式？" class="headerlink" title="如何使用 JavaScript 中的正则表达式（Regular Expression）？有哪些常见的正则表达式模式？"></a>如何使用 JavaScript 中的正则表达式（Regular Expression）？有哪些常见的正则表达式模式？</h2><p>正则表达式是一种用于匹配文本的模式，JavaScript 中使用 RegExp 类型或正则表达式字面量来创建和操作正则表达式。常见的正则表达式模式包括匹配数字、字母、空白字符、URL 等。</p>
<h2 id="什么是-JavaScript-中的事件循环机制（Event-Loop）？如何理解其中的微任务和宏任务？"><a href="#什么是-JavaScript-中的事件循环机制（Event-Loop）？如何理解其中的微任务和宏任务？" class="headerlink" title="什么是 JavaScript 中的事件循环机制（Event Loop）？如何理解其中的微任务和宏任务？"></a>什么是 JavaScript 中的事件循环机制（Event Loop）？如何理解其中的微任务和宏任务？</h2><p>事件循环机制是 JavaScript 运行时中处理异步操作的核心机制，微任务和宏任务是异步事件的两种类型。微任务是在当前执行栈为空时立即执行的任务（如 Promise.then()），而宏任务则需要等待下一个事件循环周期才会执行（如 setTimeout）。了解事件循环机制可以帮助开发者更好地处理异步编程和避免性能问题。</p>
<h2 id="什么是变量提升？"><a href="#什么是变量提升？" class="headerlink" title="什么是变量提升？"></a>什么是变量提升？</h2><p>变量提升是指在执行代码之前，JS 引擎会先处理函数声明和变量声明，将其放入内存中，从而使得函数和变量可以在声明之前被引用。变量声明优先级低于函数声明，避免变量污染可以通过使用 let 或 const 来定义块级作用域。</p>
<h2 id="如何使用生成器（Generator）函数？它们有什么特殊之处？"><a href="#如何使用生成器（Generator）函数？它们有什么特殊之处？" class="headerlink" title="如何使用生成器（Generator）函数？它们有什么特殊之处？"></a>如何使用生成器（Generator）函数？它们有什么特殊之处？</h2><p>生成器（Generator）函数是一种特殊的函数，可以通过 yield 语句来暂停函数的执行，并返回一个可迭代的对象。生成器函数可以逐步产生新的值，而不是一次性返回所有值。生成器函数通常用于处理大型数据集或无限序列。</p>
<h2 id="什么是迭代器（Iterator）和可迭代对象（Iterable）？如何使用它们？"><a href="#什么是迭代器（Iterator）和可迭代对象（Iterable）？如何使用它们？" class="headerlink" title="什么是迭代器（Iterator）和可迭代对象（Iterable）？如何使用它们？"></a>什么是迭代器（Iterator）和可迭代对象（Iterable）？如何使用它们？</h2><p>迭代器（Iterator）是一个对象，它能够迭代（遍历）一个容器（例如列表或字典）中的所有元素。可迭代对象（Iterable）是一个带有<strong>iter</strong>()方法的对象，它返回一个迭代器。使用迭代器和可迭代对象可以遍历各种类型的数据结构，如列表、元组、字典等。</p>
<h2 id="什么是闭包中的循环问题？如何解决？"><a href="#什么是闭包中的循环问题？如何解决？" class="headerlink" title="什么是闭包中的循环问题？如何解决？"></a>什么是闭包中的循环问题？如何解决？</h2><p>闭包中的循环问题指的是在闭包内部使用循环变量时，可能会遇到意料之外的结果。这是因为循环变量被绑定在闭包中，并且所有迭代都共享同一个变量。为了解决这个问题，可以使用立即调用函数表达式（IIFE）或 let 关键字来创建一个新的绑定。</p>
<h2 id="什么是-IIFE（Immediately-Invoked-Function-Expression）？如何使用它？"><a href="#什么是-IIFE（Immediately-Invoked-Function-Expression）？如何使用它？" class="headerlink" title="什么是 IIFE（Immediately Invoked Function Expression）？如何使用它？"></a>什么是 IIFE（Immediately Invoked Function Expression）？如何使用它？</h2><p>IIFE 是一种立即调用的函数表达式，它可以在定义后立即执行，常用于创建独立的作用域并保护其中的变量不受全局作用域的影响。可以通过在函数定义后添加一对括号并传入参数来调用 IIFE。</p>
<h2 id="如何使用模块化编程？如何导入和导出模块？"><a href="#如何使用模块化编程？如何导入和导出模块？" class="headerlink" title="如何使用模块化编程？如何导入和导出模块？"></a>如何使用模块化编程？如何导入和导出模块？</h2><p>模块化编程指将程序分解为小的模块，每个模块负责完成一个独立的功能。在 JavaScript 中，可以使用 import 和 export 语句来导入和导出模块。导入语句用于引入其他模块中的代码，导出语句用于将代码暴露给其他模块使用。</p>
<h2 id="如何使用-JavaScript-中的异步编程模式？有哪些常见的异步编程模式？"><a href="#如何使用-JavaScript-中的异步编程模式？有哪些常见的异步编程模式？" class="headerlink" title="如何使用 JavaScript 中的异步编程模式？有哪些常见的异步编程模式？"></a>如何使用 JavaScript 中的异步编程模式？有哪些常见的异步编程模式？</h2><p>异步编程模式是 JavaScript 中处理异步操作的方式，包括回调函数、Promise、async&#x2F;await 等。其中回调函数是最基础的异步编程模式，但可能导致回调地狱问题。Promise 和 async&#x2F;await 提供了更好的语法和代码结构。</p>
<h2 id="什么是-JavaScript-中的模板字符串（Template-Literals）？如何使用它们？"><a href="#什么是-JavaScript-中的模板字符串（Template-Literals）？如何使用它们？" class="headerlink" title="什么是 JavaScript 中的模板字符串（Template Literals）？如何使用它们？"></a>什么是 JavaScript 中的模板字符串（Template Literals）？如何使用它们？</h2><p>模板字符串是一种用反引号 &#96; 包围的字符串，支持多行文本和插入表达式，可以简化字符串拼接、生成 HTML 片段等操作。</p>
<h2 id="什么是-JavaScript-中的箭头函数（Arrow-Function）？它们与传统函数有什么区别？"><a href="#什么是-JavaScript-中的箭头函数（Arrow-Function）？它们与传统函数有什么区别？" class="headerlink" title="什么是 JavaScript 中的箭头函数（Arrow Function）？它们与传统函数有什么区别？"></a>什么是 JavaScript 中的箭头函数（Arrow Function）？它们与传统函数有什么区别？</h2><p>箭头函数是一种使用 &#x3D;&gt; 符号定义的函数，与传统函数相比具有更简洁的语法和固定的 this 绑定。箭头函数中的 this 始终指向外部作用域，不会被改变，但也有一些限制。</p>
<h2 id="什么是-JavaScript-中的解构赋值（Destructuring-Assignment）？如何使用它？"><a href="#什么是-JavaScript-中的解构赋值（Destructuring-Assignment）？如何使用它？" class="headerlink" title="什么是 JavaScript 中的解构赋值（Destructuring Assignment）？如何使用它？"></a>什么是 JavaScript 中的解构赋值（Destructuring Assignment）？如何使用它？</h2><p>解构赋值是一种从数组或对象中提取值并赋给变量的语法，可以简化代码和减少重复。在 JavaScript 中，可以使用数组解构和对象解构来实现解构赋值。</p>
<h2 id="什么是-JavaScript-中的扩展运算符（Spread-Operator）和剩余参数（Rest-Parameters）？如何使用它们？"><a href="#什么是-JavaScript-中的扩展运算符（Spread-Operator）和剩余参数（Rest-Parameters）？如何使用它们？" class="headerlink" title="什么是 JavaScript 中的扩展运算符（Spread Operator）和剩余参数（Rest Parameters）？如何使用它们？"></a>什么是 JavaScript 中的扩展运算符（Spread Operator）和剩余参数（Rest Parameters）？如何使用它们？</h2><p>扩展运算符和剩余参数都使用 … 语法来实现。扩展运算符可以将数组或对象展开成多个独立的值，剩余参数则可以将多个参数合并成一个数组。常见的应用包括数组合并、对象合并、函数传参等。</p>
<h2 id="什么是-JavaScript-中的迭代器协议（Iterator-Protocol）和生成器函数（Generator-Function）？"><a href="#什么是-JavaScript-中的迭代器协议（Iterator-Protocol）和生成器函数（Generator-Function）？" class="headerlink" title="什么是 JavaScript 中的迭代器协议（Iterator Protocol）和生成器函数（Generator Function）？"></a>什么是 JavaScript 中的迭代器协议（Iterator Protocol）和生成器函数（Generator Function）？</h2><p>迭代器协议和生成器函数是 ES6 引入的两个新特性，用于处理序列数据和异步编程。迭代器协议定义了一个 next() 方法，返回一个具有 value 和 done 属性的对象，用于遍历序列数据；生成器函数通过 yield 关键字在多次执行中暂停和恢复函数的执行。</p>
<h2 id="如何使用-JavaScript-中的-Set、Map-和-WeakSet、WeakMap-数据结构？"><a href="#如何使用-JavaScript-中的-Set、Map-和-WeakSet、WeakMap-数据结构？" class="headerlink" title="如何使用 JavaScript 中的 Set、Map 和 WeakSet、WeakMap 数据结构？"></a>如何使用 JavaScript 中的 Set、Map 和 WeakSet、WeakMap 数据结构？</h2><p>Set、Map 和 WeakSet、WeakMap 数据结构是 ES6 引入的四种新类型，它们分别用于存储唯一值、键值对映射、弱引用对象集合和弱引用键值对映射等场景，提供了更丰富和灵活的数据存储方式。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS - 设计模式？</title>
    <url>/2014/05/01/%E5%89%8D%E7%AB%AF/JavaScript/JS%20-%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="收藏"><a href="#收藏" class="headerlink" title="收藏"></a>收藏</h2><p><a href="https://juejin.cn/post/6844904032826294286">JavaScript 设计模式 es6（23 种)</a><br><a href="https://juejin.cn/post/6844903506994806791">JavaScript 设计模式与开发实践</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS - 页面如何渲染？</title>
    <url>/2014/05/01/%E5%89%8D%E7%AB%AF/JavaScript/JS%20-%20%E9%A1%B5%E9%9D%A2%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%EF%BC%9F/</url>
    <content><![CDATA[<!-- # 页面如何渲染 -->

<ul>
<li>Reflow 回流</li>
<li>为什么 JavaScript 要是单线程的 ?</li>
</ul>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4. 为什么 JS 阻塞页面加载 ?</span><br><span class="line">    1. 是可操纵 DOM 的</span><br><span class="line">    2. js 会阻塞 Dom 解析，GUI 线程会被挂起，</span><br><span class="line">5. css 加载会造成阻塞吗 ？</span><br><span class="line">    1. CSS 加载会阻塞 Dom 的渲染和后面 js 的执行</span><br><span class="line">6. DOMContentLoaded 与 load 的区别 ?</span><br><span class="line">    1. DOMContentLoaded -&gt; load。</span><br><span class="line">7. 什么是 CRP,即关键渲染路径(Critical Rendering Path)? 如何优化 ?</span><br><span class="line">    1. 浏览器渲染流程。</span><br><span class="line">    2. 文件大小，阻塞，速度</span><br><span class="line">8. defer 和 async 的区别 ?</span><br><span class="line">9. 谈谈浏览器的回流与重绘 ?</span><br><span class="line">10. 什么是渲染层合并 (Composite) ?</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS - 什么作用域和闭包？</title>
    <url>/2014/05/01/%E5%89%8D%E7%AB%AF/JavaScript/JS-%20%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F/</url>
    <content><![CDATA[<!-- # 什么原型和原型链？ -->

<ul>
<li><p>每个 JavaScript 对象都有一个原型（prototype）属性，它指向另一个对象，<br>这个对象就是 当前对象的原型。</p>
<p>当对象在自己的属性上找不到某个属性或方法，它会到原型对象中查找，直到找到为止，这就是原型链。</p>
<p>原型链的顶端是 Object.prototype 对象，Object.prototype 的原型为 null。</p>
</li>
</ul>
<span id="more"></span>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>React - Fiber？</title>
    <url>/2018/05/01/%E5%89%8D%E7%AB%AF/React/React%20-%20Fiber%EF%BC%9F/</url>
    <content><![CDATA[<!-- # React - Fiber？ -->

<p>Fiber 是一种可中断的和优先级处理的协调引擎。</p>
<p>它可以提高性能、改善用户体验和支持渐进式渲染。更好地流畅管理组件树的渲染过程。</p>
<span id="more"></span>

<p>在传统的 React 版本中，组件树的更新是通过递归遍历整个树来实现的，这可能会在更新过程中阻塞主线程。<br>而使用 Fiber，React 可以将更新分解为多个小任务，并使用优先级控制算法来安排这些任务的执行顺序，以便它们可以在不影响用户体验的情况下执行。此外，Fiber 还支持中断和恢复任务的执行，以便在处理紧急事件（如用户输入）时能够及时响应。</p>
<p>Fiber 架构的另一个重要方面是它使 React 能够进行渐进式的渲染。这意味着 React 可以立即开始渲染页面并在后台继续执行剩余的工作，而不必等待所有内容都准备好才开始渲染。这可以改善首次加载时间并提高性能。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>🎉 React - Hooks？</title>
    <url>/2018/05/01/%E5%89%8D%E7%AB%AF/React/React%20-%20Hooks%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="基本挂钩"><a href="#基本挂钩" class="headerlink" title="基本挂钩"></a>基本挂钩</h2><ul>
<li>useState<ul>
<li>const [state, setState] &#x3D; useState(initialState);</li>
<li>返回一个有状态的值以及一个更新它的函数。</li>
</ul>
</li>
<li>useEffect<ul>
<li>useEffect(didUpdate);</li>
<li>接受包含命令式、可能有效的代码的函数。</li>
<li>函数 useEffect 可能会返回一个清理函数。</li>
</ul>
</li>
<li>useContext<ul>
<li>const value &#x3D; useContext(MyContext);</li>
<li>接受上下文对象并返回该上下文的当前上下文值。</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="附加挂钩"><a href="#附加挂钩" class="headerlink" title="附加挂钩"></a>附加挂钩</h2><ul>
<li>useReducer<ul>
<li>const [state, dispatch] &#x3D; useReducer(reducer, initialArg, init);</li>
<li>替代品 useState。接受 类型的减速器(state, action) &#x3D;&gt; newState，并返回与方法配对的当前状态 dispatch。（如果您熟悉 Redux，您就已经知道它是如何工作的。）</li>
</ul>
</li>
<li>useCallback<ul>
<li>返回一个记忆的回调。</li>
<li>仅当依赖项之一发生更改时该版本才会更改。</li>
</ul>
</li>
<li>useMemo<ul>
<li>返回一个记忆值。</li>
<li>如果未提供数组，则每次渲染时都会计算一个新值。</li>
</ul>
</li>
<li>useRef<ul>
<li>useRef 返回一个可变的 ref 对象，其.current 属性被初始化为传递的参数 ( initialValue)。</li>
</ul>
</li>
<li>useImperativeHandle<ul>
<li>useImperativeHandle 自定义使用时暴露给父组件的实例值 ref。应该与以下一起使用 forwardRef</li>
</ul>
</li>
<li>useLayoutEffect<ul>
<li>签名与 相同 useEffect，但它在所有 DOM 突变后同步触发。使用它从 DOM 读取布局并同步重新渲染。在浏览器有机会绘制之前，内部计划的更新 useLayoutEffect 将同步刷新。</li>
</ul>
</li>
<li>useDebugValue<ul>
<li>useDebugValue 可用于在 React DevTools 中显示自定义挂钩的标签。</li>
</ul>
</li>
<li>useDeferredValue<ul>
<li>useDeferredValue 接受一个值并返回该值的新副本，该副本将推迟到更紧急的更新。</li>
</ul>
</li>
<li>useTransition<ul>
<li>返回转换的挂起状态的有状态值以及启动它的函数。</li>
</ul>
</li>
<li>useId<ul>
<li>useId 是一个钩子，用于生成在服务器和客户端上稳定的唯一 ID，同时避免水合不匹配。</li>
</ul>
</li>
</ul>
<h2 id="其他挂钩"><a href="#其他挂钩" class="headerlink" title="其他挂钩"></a>其他挂钩</h2><ul>
<li>useSyncExternalStore<ul>
<li>useSyncExternalStore 是一个推荐用于从外部数据源读取和订阅的钩子，其方式与选择性水合和时间切片等并发渲染功能兼容。</li>
</ul>
</li>
<li>useInsertionEffect<ul>
<li>在所有 DOM 突变之前 useEffect 同步触发。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React - Virtual DOM？</title>
    <url>/2018/05/01/%E5%89%8D%E7%AB%AF/React/React%20-%20Virtual%20DOM%EF%BC%9F/</url>
    <content><![CDATA[<!-- # React - Virtual DOM？ -->

<p>Virtual DOM 是一个轻量级的 JavaScript 对象，描述了真实 DOM 的层次结构。</p>
<p>在 React 中，当状态发生变化时，React 会创建一个新的 Virtual DOM 对象来代表新的 DOM 层次结构，并使用算法比较旧的和新的 Virtual DOM 对象之间的不同之处。根据 diff 算法的结果，React 只更新需要更改的部分，而不需要重新渲染整个页面。</p>
<span id="more"></span>

<p>Virtual DOM 是 React 用于提高性能的重要机制。它是一个轻量级的 JavaScript 对象树，用于表示真实的 DOM 结构，并且与真实的 DOM 保持同步。在 React 应用程序中，当状态发生变化时，React 首先会更新 Virtual DOM，然后通过比较前后两个版本的 Virtual DOM，计算出需要更新的最小操作，最后只更新这些操作对应的真实 DOM 节点，从而提高性能和减少不必要的 DOM 操作。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>🎉 useMemo 和 useCallback 区别？</title>
    <url>/2018/05/01/%E5%89%8D%E7%AB%AF/React/React%20-%20useMemo%20%E5%92%8C%20useCallback%20%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="useMemo-和-useCallback-在缓存的对象和返回值上存在差异，但二者都可以优化-React-函数组件性能。"><a href="#useMemo-和-useCallback-在缓存的对象和返回值上存在差异，但二者都可以优化-React-函数组件性能。" class="headerlink" title="useMemo 和 useCallback 在缓存的对象和返回值上存在差异，但二者都可以优化 React 函数组件性能。"></a>useMemo 和 useCallback 在缓存的对象和返回值上存在差异，但二者都可以优化 React 函数组件性能。</h2><hr>
<h2 id="useMemo-可以根据依赖项的变化来缓存计算结果，从而避免不必要的重复计算。例如："><a href="#useMemo-可以根据依赖项的变化来缓存计算结果，从而避免不必要的重复计算。例如：" class="headerlink" title="useMemo 可以根据依赖项的变化来缓存计算结果，从而避免不必要的重复计算。例如："></a>useMemo 可以根据依赖项的变化来缓存计算结果，从而避免不必要的重复计算。例如：</h2><span id="more"></span>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">computeExpensiveValue</span>(a, b), [a, b]);</span><br></pre></td></tr></table></figure>

<p>这里的 computeExpensiveValue 是一个计算成本很高的函数，memoizedValue 将会被缓存，并且只有在 a 或 b 发生变化时才会重新计算。</p>
<h2 id="useCallback-则是用于缓存回调函数，以避免不必要的重复创建。例如："><a href="#useCallback-则是用于缓存回调函数，以避免不必要的重复创建。例如：" class="headerlink" title="useCallback 则是用于缓存回调函数，以避免不必要的重复创建。例如："></a>useCallback 则是用于缓存回调函数，以避免不必要的重复创建。例如：</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">doSomethingWith</span>(a, b);</span><br><span class="line">&#125;, [a, b]);</span><br></pre></td></tr></table></figure>

<p>这里的 memoizedCallback 将会被缓存，并且只有在 a 或 b 发生变化时才会重新创建。如果我们将这个回调函数传递给了子组件，那么子组件在重新渲染时就不需要重新创建这个回调函数，从而避免了不必要的重复渲染。</p>
<p>使用 useMemo 和 useCallback 都可以有效地避免在 React 应用程序中重复渲染组件，提高应用程序的性能和响应速度。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>🎉 - useState 和 useReducer 的区别是什么？</title>
    <url>/2018/05/01/%E5%89%8D%E7%AB%AF/React/React%20-%20useState%20%E5%92%8C%20useReducer%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p>useState 和 useReducer 都是 React 中用于管理组件的状态。</p>
<h2 id="主要区别："><a href="#主要区别：" class="headerlink" title="主要区别："></a>主要区别：</h2><h3 id="useState："><a href="#useState：" class="headerlink" title="useState："></a>useState：</h3><ul>
<li>只能处理<code>单个</code>状态值，可以通过多次调用。</li>
</ul>
<span id="more"></span>

<h3 id="useReducer："><a href="#useReducer：" class="headerlink" title="useReducer："></a>useReducer：</h3><ul>
<li><p>适用于<code>复杂的状态</code>管理，可以处理多个相关联的状态值，并支持在更新状态时执行自定义操作。</p>
</li>
<li><p>useReducer 接受一个 reducer 函数和初始状态，并返回当前状态和 dispatch 函数，用于触发状态更新。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React - 如何处理错误信息？</title>
    <url>/2018/05/01/%E5%89%8D%E7%AB%AF/React/React%20-%20%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%EF%BC%9F/</url>
    <content><![CDATA[<!-- # React - 如何处理错误信息？ -->

<p>在组件中通过定义 componentDidCatch 生命周期方法来捕获错误，并使用 ErrorBoundary 组件或 static getDerivedStateFromError 方法来处理错误。</p>
<p>目前没有办法将错误边界写成函数组件。但是，您不必自己编写错误边界类。例如，您可以 react-error-boundary 改为使用。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React - 如何实现懒加载？</title>
    <url>/2018/05/01/%E5%89%8D%E7%AB%AF/React/React%20-%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%9F/</url>
    <content><![CDATA[<!-- # React - 如何实现懒加载？ -->

<p>可以通过使用 React.lazy 和 Suspense 组件，在需要时才动态加载组件代码。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React - 属性key作用？</title>
    <url>/2018/05/01/%E5%89%8D%E7%AB%AF/React/React%20-%20%E5%B1%9E%E6%80%A7key%E4%BD%9C%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<!-- # React - 属性 key 作用？ -->

<p>Key 是 React 用于识别哪些元素已经被修改、添加或删除的机制。当我们使用数组渲染组件列表时，每个组件都需要有一个唯一的 key 属性，这样 React 就可以快速确定哪些组件需要更新，避免不必要的渲染，从而提高性能。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React - 性能优化？</title>
    <url>/2018/05/01/%E5%89%8D%E7%AB%AF/React/React%20-%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F/</url>
    <content><![CDATA[<!-- # React - 性能优化？ -->

<p>避免重复渲染： 使用 shouldComponentUpdate，PureComponent，React.memo<br>函数组件：useMemo 和 useCallback 函数<br>组件懒加载：React.lazy 和 Suspense<br>使用 key 属性<br>按需加载模块<br>SSR 提高首屏渲染速度<br>Web Workers 避免阻塞 UI 线程</p>
<span id="more"></span>

<h1 id="避免重复渲染组件？🔥"><a href="#避免重复渲染组件？🔥" class="headerlink" title="避免重复渲染组件？🔥"></a>避免重复渲染组件？🔥</h1><p>使用 shouldComponentUpdate，PureComponent，React.memo<br>函数组件：useMemo 和 useCallback 函数</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React - 组件通信？</title>
    <url>/2018/05/01/%E5%89%8D%E7%AB%AF/React/React%20-%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%EF%BC%9F/</url>
    <content><![CDATA[<!-- # React - 组件通信？ -->

<ul>
<li>常用的组件通信方式包括：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">props、</span><br><span class="line"></span><br><span class="line">Context、</span><br><span class="line"></span><br><span class="line">Redux</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="如何使用-React-Context-来管理全局数据？"><a href="#如何使用-React-Context-来管理全局数据？" class="headerlink" title="如何使用 React Context 来管理全局数据？"></a>如何使用 React Context 来管理全局数据？</h1><p>简单回答下：<br>可以通过 React.createContext 方法创建一个 Context 实例，并通过 Provider 组件来向下传递数据，而子组件可以通过 Consumer 组件或 useContext 钩子来获取这些数据。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React - 高阶组件？</title>
    <url>/2018/05/01/%E5%89%8D%E7%AB%AF/React/React%20-%20%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%EF%BC%9F/</url>
    <content><![CDATA[<!-- # React - 高阶组件？ -->

<p>高阶组件是指接受一个组件并返回一个新组件的函数。和高阶函数一样同理。</p>
<p>主要作用：在组件之间共享代码、提取和重用状态逻辑，或者对包装的组件额外的操作。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Ts - TypeScript 中的泛型是什么？</title>
    <url>/2022/02/01/%E5%89%8D%E7%AB%AF/Typescript/Ts%20-%20TypeScript%20%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<!-- # TypeScript 中的泛型是什么？如何使用泛型？ -->

<p>TypeScript 中的泛型是一种类型参数，它可以在定义函数、类或接口时使用，用于指定一个类型占位符。<br>这个类型占位符可以在调用函数或实例化类时被具体的类型所代替，从而实现代码的灵活性和复用性。</p>
<p>代码示范：</p>
<span id="more"></span>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 TypeScript 中使用命名空间？</title>
    <url>/2022/02/01/%E5%89%8D%E7%AB%AF/Typescript/Ts%20-%20%E5%A6%82%E4%BD%95%E5%9C%A8%20TypeScript%20%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%9F/</url>
    <content><![CDATA[<!-- # 如何在 TypeScript 中使用命名空间？ -->

<p>简单回答下：<br>在 TypeScript 中，命名空间是一种用于组织代码的结构化方式。<br>我们可以使用命名空间来避免命名冲突，并将相关的函数、类和接口等组织到一个逻辑单元中。</p>
<p>代码示范：</p>
<span id="more"></span>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">namespace <span class="title class_">MyNamespace</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> interface <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: string;</span><br><span class="line">    <span class="attr">age</span>: number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">person: Person</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;person.name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: <span class="title class_">MyNamespace</span>.<span class="property">Person</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"><span class="title class_">MyNamespace</span>.<span class="title function_">sayHello</span>(person);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Ts - 如何定义接口？</title>
    <url>/2022/02/01/%E5%89%8D%E7%AB%AF/Typescript/Ts%20-%20%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%EF%BC%9F/</url>
    <content><![CDATA[<!-- # Ts - 如何使用接口来描述函数类型？ -->

<p>代码示范：</p>
<span id="more"></span>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">AddFunction</span> &#123;</span><br><span class="line">    (<span class="attr">x</span>: number, <span class="attr">y</span>: number): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Ts-interface-和-type-区别？"><a href="#Ts-interface-和-type-区别？" class="headerlink" title="Ts - interface 和 type 区别？"></a>Ts - interface 和 type 区别？</h1><p>interface 主要用于描述对象的结构，可继承</p>
<p>type 更适合用于描述一般的类型，type 能够给任何类型起别名，</p>
<p>type 支持使用 &amp; 运算符实现交叉类型，使用 | 运算符实现联合类型。</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue - 中实现组件通信？</title>
    <url>/2022/01/01/%E5%89%8D%E7%AB%AF/Vue/Vue%20-%20%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%EF%BC%9F/</url>
    <content><![CDATA[<!-- # Vue2 中实现组件通信？ -->

<ol>
<li>Props：props 向子组件传递数据，</li>
<li>Events：父组件通过子组件通过 emit 事件向父组件触发事件进行通信。</li>
<li>$attrs：属性透传</li>
</ol>
<span id="more"></span>

<h1 id="Vue3-中实现组件通信？"><a href="#Vue3-中实现组件通信？" class="headerlink" title="Vue3 中实现组件通信？"></a>Vue3 中实现组件通信？</h1><ol>
<li>provide&#x2F;inject：与 Vuex 不同的是，它是基于依赖注入的方式实现的。父组件通过 provide 提供数据，子孙组件通过 inject 来注入数据，从而实现了跨层级的组件通信。</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue - 中的 computed 和 watch 区别？</title>
    <url>/2022/01/01/%E5%89%8D%E7%AB%AF/Vue/Vue%20-%20%E4%B8%AD%E7%9A%84%20computed%20%E5%92%8C%20watch%20%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<!-- # Vue - 中的 computed 和 watch 区别？ -->

<p>在 Vue 中，computed 和 watch 都可以用于监听数据变化并做出响应。 区别在于：</p>
<ol>
<li>计算属性 (computed)：可以处理依赖关系，并且具有缓存机制。</li>
</ol>
<span id="more"></span>

<ol start="2">
<li>监听器 (watch)：能够响应数据的变化，并在数据变化时执行指定的操作。监听器不会缓存值，每次数据变化都会触发回调函数。</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue - 中的 mixin 和 extends 优缺点？</title>
    <url>/2022/01/01/%E5%89%8D%E7%AB%AF/Vue/Vue%20-%20%E4%B8%AD%E7%9A%84%20mixin%20%E5%92%8C%20extends%20%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F/</url>
    <content><![CDATA[<!-- # Vue - 中的 mixin 和 extends 优缺点？ -->

<p>mixin</p>
<p>优点：<br>可以包含任意选项，具有很大的灵活性；<br>可以复用在多个组件中，提高了代码的复用性和维护性；<br>可以通过 Vue.mixin 全局混入到所有组件中，扩展了 Vue 的能力。</p>
<span id="more"></span>

<p>缺点：<br>由于 mixin 会与组件本身的选项合并，可能会导致命名冲突或者选项被覆盖的问题；<br>滥用 mixin 可能导致代码变得难以理解和维护。</p>
<p>extends</p>
<p>优点：<br>可以方便地扩展基础组件的选项，节省了编写重复代码的时间；<br>使组件的继承关系更加清晰，易于理解。</p>
<p>缺点：<br>扩展基础组件的选项可能会与其他组件的选项产生冲突；<br>继承链过长可能会导致性能问题。</p>
<h1 id="Vue-中的-mixins-是什么？如何使用它？"><a href="#Vue-中的-mixins-是什么？如何使用它？" class="headerlink" title="# Vue 中的 mixins 是什么？如何使用它？"></a># Vue 中的 mixins 是什么？如何使用它？</h1><p>在 Vue 中，mixins 是一种可重用的组件选项。它允许你在多个组件中共享相同的逻辑或功能，从而避免代码复制和粘贴。</p>
<p>具体来说，mixins 提供了一种方式将组件选项合并为一个新的选项对象，然后传递给组件创建函数。这样，组件可以继承这些选项，并且可以根据需要进行覆盖或修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const myMixin = &#123; // mixin 选项 &#125; new Vue(&#123; mixins: [myMixin], // 组件选项 &#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue - 中的 v-model 指令？</title>
    <url>/2022/01/01/%E5%89%8D%E7%AB%AF/Vue/Vue%20-%20%E4%B8%AD%E7%9A%84%20v-model%20%E6%8C%87%E4%BB%A4%EF%BC%9F/</url>
    <content><![CDATA[<!-- # Vue - 中的 v-model 指令？ -->

<p>它可以简化表单元素上的双向数据绑定。它通常用于对表单元素的输入值进行绑定，这样数据就会在视图和模型之间自动同步。</p>
<span id="more"></span>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>v-model 是什么。语法糖 :value + @input。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原生DOM input select textarea</span></span><br><span class="line">&lt;input v-model=<span class="string">&quot;val&quot;</span>&gt;</span><br><span class="line">&#123;<span class="comment">/* &lt;!-- 基本等价于，因为内部还有一些其他的处理 --&gt; */</span>&#125;</span><br><span class="line">&lt;input :value=<span class="string">&quot;val&quot;</span> @input=<span class="string">&quot;val = $event.target.value&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* 自定义组件 */</span>&#125;</span><br><span class="line">&lt;v-input v-model=<span class="string">&quot;val&quot;</span>&gt;&lt;/v-input&gt;</span><br><span class="line">&#123;<span class="comment">/* &lt;!-- 等价于 --&gt; */</span>&#125;</span><br><span class="line">&lt;v-input :value=<span class="string">&quot;val&quot;</span> @input=<span class="string">&quot;val = $event&quot;</span>&gt;&lt;/v-input&gt;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://cn.vuejs.org/guide/components/v-model.html">https://cn.vuejs.org/guide/components/v-model.html</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue - 什么是 Virtual DOM，优势？</title>
    <url>/2022/01/01/%E5%89%8D%E7%AB%AF/Vue/Vue%20-%20%E4%BB%80%E4%B9%88%E6%98%AF%20Virtual%20DOM%EF%BC%8C%E4%BC%98%E5%8A%BF%EF%BC%9F/</url>
    <content><![CDATA[<!-- # Vue - 什么是 Virtual DOM，优势？ -->

<p>它是一个内存中的虚拟节点树，其结构与真实的 DOM 树相似，但是它只存在于内存中，并不需要直接操作浏览器中的 DOM。当数据发生变化时，框架会先利用算法比较新旧虚拟 DOM 的差异，并仅更新需要更新的部分。</p>
<span id="more"></span>

<h1 id="虚拟-DOM-的优势："><a href="#虚拟-DOM-的优势：" class="headerlink" title="虚拟 DOM 的优势："></a>虚拟 DOM 的优势：</h1><ol>
<li><p>性能优化：虚拟 DOM 可以通过判断传入数据是否有变化来决定是否需要重新渲染整个组件，从而避免了无谓的重绘和回流操作，提高了页面渲染性能。</p>
</li>
<li><p>开发效率：虚拟 DOM 使得开发者可以将精力集中在业务逻辑上，不需要关注底层 DOM 操作，从而提高了开发效率。</p>
</li>
<li><p>跨平台支持：由于虚拟 DOM 只是一个内存中的对象，因此可以在不同平台上使用相同的代码，比如浏览器、移动端和服务器端渲染等。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue - 如何实现路由守卫？</title>
    <url>/2022/01/01/%E5%89%8D%E7%AB%AF/Vue/Vue%20-%20%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%EF%BC%9F/</url>
    <content><![CDATA[<!-- # Vue - 如何实现路由守卫？ -->

<p>在 Vue 中，可以通过守卫来拦截导航、验证用户身份等操作。</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设路由表</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>, <span class="attr">component</span>: <span class="title class_">Home</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>, <span class="attr">component</span>: <span class="title class_">About</span>, <span class="attr">meta</span>: &#123; <span class="attr">requiresAuth</span>: <span class="literal">true</span> &#125; &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">routes.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 需要登录验证但用户未登录</span></span><br><span class="line">    <span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">requiresAuth</span> &amp;&amp; !auth.<span class="title function_">isLoggedIn</span>()) &#123;</span><br><span class="line">        <span class="title function_">next</span>(<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 继续导航</span></span><br><span class="line">        <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://router.vuejs.org/guide/advanced/meta.html">https://router.vuejs.org/guide/advanced/meta.html</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue - 数据双向绑定？</title>
    <url>/2022/01/01/%E5%89%8D%E7%AB%AF/Vue/Vue%20-%20%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="收藏"><a href="#收藏" class="headerlink" title="收藏"></a>收藏</h2><p><a href="https://juejin.cn/post/6844903903822086151#heading-17">Vue 核心之数据双向绑定</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue - 有哪些性能优化？</title>
    <url>/2022/01/01/%E5%89%8D%E7%AB%AF/Vue/Vue%20-%20%E6%9C%89%E5%93%AA%E4%BA%9B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F/</url>
    <content><![CDATA[<!-- # Vue - 有哪些性能优化？ -->

<ol>
<li><p>避免不必要的重渲染 beforeUpdate，watch</p>
</li>
<li><p>使用 v-if 和 v-show 指令</p>
</li>
</ol>
<span id="more"></span>

<ol start="3">
<li><p>合理使用计算属性和缓存</p>
</li>
<li><p>使用异步组件：Vue 提供了异步组件来延迟加载组件，可以大大提高应用程序的初始加载速度和性能。</p>
</li>
<li><p>使用 keep-alive 缓存组件状态</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue - 生命周期的理解？</title>
    <url>/2022/01/01/%E5%89%8D%E7%AB%AF/Vue/Vue%20-%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/</url>
    <content><![CDATA[<p>生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>
<span id="more"></span>

<h1 id="组件调用执行过程"><a href="#组件调用执行过程" class="headerlink" title="组件调用执行过程"></a>组件调用执行过程</h1><h2 id="加载渲染过程"><a href="#加载渲染过程" class="headerlink" title="加载渲染过程"></a>加载渲染过程</h2><p>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
<h2 id="子组件更新过程"><a href="#子组件更新过程" class="headerlink" title="子组件更新过程"></a>子组件更新过程</h2><p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
<h2 id="父组件更新过程"><a href="#父组件更新过程" class="headerlink" title="父组件更新过程"></a>父组件更新过程</h2><p>父 beforeUpdate -&gt; 父 updated</p>
<h2 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h2><p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
<h2 id="生命周期内调用异步请求？"><a href="#生命周期内调用异步请求？" class="headerlink" title="生命周期内调用异步请求？"></a>生命周期内调用异步请求？</h2><pre><code>可以在钩子函数 created、beforeMount、mounted 中进行调用，推荐在 created 钩子。
</code></pre>
<h2 id="什么阶段才能访问操作-DOM？"><a href="#什么阶段才能访问操作-DOM？" class="headerlink" title="什么阶段才能访问操作 DOM？"></a>什么阶段才能访问操作 DOM？</h2><pre><code>在 mounted 中可以访问操作 DOM。
</code></pre>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue - 虚拟 DOM 实现原理？</title>
    <url>/2022/01/01/%E5%89%8D%E7%AB%AF/Vue/Vue%20-%20%E8%99%9A%E6%8B%9F%20DOM%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F/</url>
    <content><![CDATA[<p>虚拟 DOM 的实现原理主要包括以下 3 部分：</p>
<p>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；<br>diff 算法 — 比较两棵虚拟 DOM 树的差异；<br>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</p>
<p><a href="https://juejin.cn/post/6844903895467032589#heading-14">深入剖析：Vue 核心之虚拟 DOM</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs - 中使用流？</title>
    <url>/2016/05/01/%E5%90%8E%E7%AB%AF/Nodejs/Nodejs%20-%20%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B5%81%EF%BC%9F/</url>
    <content><![CDATA[<!-- # Nodejs - 中使用流？ -->

<p>在 Node.js 中使用流需要使用核心的 stream 模块。例如，可以使用 createReadStream 方法创建一个可读流并使用 pipe 方法将数据写入可写流：</p>
<p>代码示范：</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readStream = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;file.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> writeStream = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;output.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line">readStream.<span class="title function_">pipe</span>(write</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs - 事件循环？</title>
    <url>/2016/05/01/%E5%90%8E%E7%AB%AF/Nodejs/Nodejs%20-%20%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%9F/</url>
    <content><![CDATA[<!-- # Nodejs - 事件循环？ -->

<p>Node.js 中的事件循环是一种异步执行模型，它通过监听事件队列中的事件并调用相应的回调函数来处理请求。事件循环始终处于运行状态，处理每个进入队列的事件并返回结果。</p>
<span id="more"></span>

<h1 id="loop-官方"><a href="#loop-官方" class="headerlink" title="loop 官方"></a>loop 官方</h1><pre><code>什么是事件循环？
事件循环允许 Node.js 通过尽可能将操作卸载到系统内核来执行非阻塞 I/O 操作 ——尽管 JavaScript 是单线程的。

事件循环解释
当 Node.js 启动时，它会初始化事件循环，处理提供的输入脚本，这可能会进行异步 API 调用、调度计时器或调用 process.nextTick()，然后开始处理事件环形。
</code></pre>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick">官方文档链接 https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick</a></p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs - 创建一个 HTTP 服务器？</title>
    <url>/2016/05/01/%E5%90%8E%E7%AB%AF/Nodejs/Nodejs%20-%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%20HTTP%20%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F/</url>
    <content><![CDATA[<!-- # Nodejs - 创建一个 HTTP 服务器？ -->

<p>使用 Node.js 创建一个 HTTP 服务器需要使用核心的 http 模块。例如，可以使用 createServer 方法创建一个服务器实例，并在回调函数中处理请求和响应：</p>
<p>代码示范：</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="property">statusCode</span> = <span class="number">200</span>;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Server running at http://localhost:3000/&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs - 处理文件系统？</title>
    <url>/2016/05/01/%E5%90%8E%E7%AB%AF/Nodejs/Nodejs%20-%20%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%9F/</url>
    <content><![CDATA[<!-- # Nodejs - 处理文件系统？ -->

<p>在 Node.js 中处理文件系统需要使用核心的 fs 模块。例如，可以使用 readFile 方法读取文件内容，并在回调函数中处理结果：</p>
<p>代码示范：</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs - 概述？</title>
    <url>/2016/05/01/%E5%90%8E%E7%AB%AF/Nodejs/Nodejs%20-%20%E6%A6%82%E8%BF%B0%EF%BC%9F/</url>
    <content><![CDATA[<!-- # Nodejs - 概述？ -->

<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时，它在服务器端运行 JavaScript 代码。它的主要特点是非阻塞 I&#x2F;O，事件驱动和高效性能。</p>
<span id="more"></span>

<h1 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h1><p>2009</p>
<p>Node.js 发布<br>创建 npm  的第一种形式</p>
<p>2010</p>
<p>Express  发布<br>Socket.io  发布</p>
<p>2011</p>
<p>npm 发布 1.0 版本<br>大公司开始采用 Node.js: 像 LinkedIn, Uber 等等。<br>hapi  发布</p>
<p>2012</p>
<p>持续被更多人所使用</p>
<p>2013</p>
<p>第一个使用 Node.js 的大型博客平台: Ghost<br>Koa  发布</p>
<p>2014</p>
<p>分裂分支: io.js 是 Node.js 分裂出的主要分支, 目标是引入 ES6 的支持并更快的开发迭代。</p>
<p>2015</p>
<p>Node.js 基金会   诞生<br>IO.js 合并回 Node.js<br>npm 引入私有模块<br>Node.js 4 (以前从未发布过 1, 2 和 3 版本)</p>
<p>2016</p>
<p>kik, left-pad 和 npm 事件<br>Yarn  发布<br>Node.js 6</p>
<p>2017</p>
<p>npm 更注重安全性<br>Node.js 8<br>HTTP&#x2F;2<br>V8 在其测试套件中引入 Node.js，正式使 Node.js 成为除 Chrome 之外的 JS 引擎的目标<br>每周超 30 亿次 npm 下载</p>
<p>2018</p>
<p>Node.js 10<br>ES modules .mjs 实验支持</p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs - 访问数据库？</title>
    <url>/2016/05/01/%E5%90%8E%E7%AB%AF/Nodejs/Nodejs%20-%20%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F/</url>
    <content><![CDATA[<!-- # Nodejs - 访问数据库？ -->

<p>在 Node.js 中访问数据库需要使用适当的数据库驱动程序。常见的数据库驱动程序包括 MongoDB 的 mongodb 模块和 MySQL 的 mysql2 模块。以下是使用 mongodb 模块连接到 MongoDB 并查询数据的示例：</p>
<p>代码示范：</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MongoClient</span> = <span class="built_in">require</span>(<span class="string">&quot;mongodb&quot;</span>).<span class="property">MongoClient</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&quot;mongodb://localhost:27017/myproject&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url, <span class="function">(<span class="params">err, client</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Connected successfully to server&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> db = client.<span class="title function_">db</span>(<span class="string">&quot;myproject&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> collection = db.<span class="title function_">collection</span>(<span class="string">&quot;documents&quot;</span>);</span><br><span class="line"></span><br><span class="line">    collection.<span class="title function_">find</span>(&#123;&#125;).<span class="title function_">toArray</span>(<span class="function">(<span class="params">err, docs</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Found the following records&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(docs);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    client.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 会话</title>
    <url>/2014/05/01/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/HTTP%20%E4%BC%9A%E8%AF%9D/</url>
    <content><![CDATA[<p><img src="/images/w3c.png"></p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 的发展</title>
    <url>/2014/05/01/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/HTTP%20%E7%9A%84%E5%8F%91%E5%B1%95/</url>
    <content><![CDATA[<p><img src="/images/w3c.png"></p>
<h2 id="HTTP（HyperText-Transfer-Protocol）是万维网（World-Wide-Web）的基础协议。"><a href="#HTTP（HyperText-Transfer-Protocol）是万维网（World-Wide-Web）的基础协议。" class="headerlink" title="HTTP（HyperText Transfer Protocol）是万维网（World Wide Web）的基础协议。"></a>HTTP（HyperText Transfer Protocol）是万维网（World Wide Web）的基础协议。</h2><p>自 Tim Berners-Lee 博士和他的团队在 1989-1991 年间创造出它以来，HTTP 已经发生了太多的变化，在保持协议简单性的同时，不断扩展其灵活性。如今，HTTP 已经从一个只在实验室之间交换文件的早期协议进化到了可以传输图片，高分辨率视频和 3D 效果的现代复杂互联网协议。</p>
<span id="more"></span>

<h2 id="万维网的发明"><a href="#万维网的发明" class="headerlink" title="万维网的发明"></a>万维网的发明</h2><p>1989 年，当时在 CERN 工作的 Tim Berners-Lee 博士写了一份关于建立一个通过网络传输超文本系统的报告。这个系统起初被命名为 Mesh，在随后的 1990 年项目实施期间被更名为万维网（World Wide Web）。它在现有的 TCP 和 IP 协议基础之上建立，由四个部分组成：</p>
<ul>
<li>一个用来表示超文本文档的文本格式，超文本标记语言（HTML）。</li>
<li>一个用来交换超文本文档的简单协议，超文本传输协议（HTTP）。</li>
<li>一个显示（以及编辑）超文本文档的客户端，即网络浏览器。第一个网络浏览器被称为 WorldWideWeb。</li>
<li>一个服务器用于提供可访问的文档，即 httpd 的前身。</li>
</ul>
<h2 id="HTTP-x2F-2——为了更优异的表现"><a href="#HTTP-x2F-2——为了更优异的表现" class="headerlink" title="HTTP&#x2F;2——为了更优异的表现"></a>HTTP&#x2F;2——为了更优异的表现</h2><p>HTTP&#x2F;2 在 HTTP&#x2F;1.1 有几处基本的不同：</p>
<p>HTTP&#x2F;2 是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。<br>这是一个多路复用协议。并行的请求能在同一个链接中处理，移除了 HTTP&#x2F;1.x 中顺序和阻塞的约束。<br>压缩了标头。因为标头在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。<br>其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。</p>
<p>在 2015 年 5 月正式标准化后，HTTP&#x2F;2 取得了极大的成功，在 2022 年 1 月达到峰值，占所有网站的 46.9%（见这些统计数据）。高流量的站点最迅速的普及，在数据传输上节省了可观的成本和支出。</p>
<h2 id="HTTP-x2F-3——基于-QUIC-的-HTTP"><a href="#HTTP-x2F-3——基于-QUIC-的-HTTP" class="headerlink" title="HTTP&#x2F;3——基于 QUIC 的 HTTP"></a>HTTP&#x2F;3——基于 QUIC 的 HTTP</h2><p>HTTP 的下一个主要版本，HTTP&#x2F;3 有这与 HTTP 早期版本的相同语义，但在传输层部分使用 QUIC (en-US) 而不是 TCP。到 2022 年 10 月，26% 的网站正在使用 HTTP&#x2F;3。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP&#x2F;Evolution_of_HTTP</a></p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 安全</title>
    <url>/2014/05/01/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/HTTP%20%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<p><img src="/images/w3c.png"></p>
<h2 id="HTTPS（超文本传输安全协议）是-HTTP-协议的加密版本。"><a href="#HTTPS（超文本传输安全协议）是-HTTP-协议的加密版本。" class="headerlink" title="HTTPS（超文本传输安全协议）是 HTTP 协议的加密版本。"></a>HTTPS（超文本传输安全协议）是 HTTP 协议的加密版本。</h2><p>它使用 SSL 或 TLS 协议来加密客户端和服务器之间所有的通信。安全连接允许客户端与服务器安全地交换敏感数据，例如网上银行或者在线商城等涉及金钱的操作。</p>
<h2 id="SSL（安全套接层）"><a href="#SSL（安全套接层）" class="headerlink" title="SSL（安全套接层）"></a>SSL（安全套接层）</h2><p>SSL（Secure Sockets Layer，安全套接层）是旧的标准安全技术，用于在服务器和客户端之间创建加密的网络链路，确保传递的所有数据都是私密且安全的。SSL 的当前版本是 Netscape 于 1996 年发布的 3.0 版本，已被 TLS 协议取代。</p>
<h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><p>传输层安全性协议 (Transport Layer Security，缩写作 TLS)，它的前身是安全套接层 (Secure Sockets Layer，缩写作 SSL)，是一个被应用程序用来在网络中安全通信的 protocol （通讯协议），防止电子邮件、网页、消息以及其他协议被篡改或是窃听。</p>
<p>所有现代浏览器都支持 TLS 协议，它们都要求服务器提供一个有效的 digital certificate（数字证书）来确认身份以建立安全连接。如果客户端和服务器都能提供自己的数字证书，则它们可以互相认证。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手四次握手</title>
    <url>/2014/05/01/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/TCP%20%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p><img src="/images/w3c.png"></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>传输控制协议（TCP）是主要的网络协议之一。它使两台主机能够建立连接并交换数据流。TCP 能保证数据的交付，维持数据包的发送顺序。TCP 在 1970 年代被两位 DARPA 的科学家 Vint Cerf 和 Bob Kahn 所设计出来，他们当时被称为互联网之父。</p>
<span id="more"></span>

<p>深入<br>TCP 是互联网的基本通信语言协议。它会校验包的交付。TCP 被用于 Web 浏览器连接到互联网时以及从一个地址向另一个地址发送文件传递电子邮件。TCP 确保数据传输的可靠性，并且保证每一个字节在接收时维持它们的发送顺序。操作系统通过一个编程接口来管理 TCP。TCP 使用三次握手来建立一个连接和四次握手来中断一个连接。</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ol>
<li><p>客户端向服务器发送一个同步请求（SYN），告诉服务器客户端要开始建立连接。</p>
</li>
<li><p>服务器收到客户端的 SYN 请求后，回复一个同步确认（SYN-ACK），告诉客户端已经收到了请求，并准备好建立连接。</p>
</li>
<li><p>客户端收到服务器的 SYN-ACK 响应后，再次发送一个确认请求（ACK）（SYN&#x3D;0，ACK&#x3D;1，Seq&#x3D;X+1，Ack&#x3D;Y+1），告诉服务器客户端已经接收到了服务器的响应，并表示可以开始传输数据。</p>
</li>
</ol>
<p>需要注意的是，在三次握手过程中，如果某个阶段超时或出错，则会重新开始三次握手过程。同时，在连接关闭时还需要进行四次挥手过程来正常关闭连接。</p>
<h2 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h2><ol>
<li><p>客户端发送，FIN 包，请求关闭；</p>
</li>
<li><p>服务端接收到， 发送一个 ACK 包，表示确认收到</p>
</li>
<li><p>服务端发送一个 FIN 包，表示服务端也不再向客户端发送数据。</p>
</li>
<li><p>客户端接收到服务端的 FIN 包后，发送一个 ACK 包，表示确认收到，连接关闭完成。</p>
</li>
</ol>
<p>需要注意的是，在四次挥手过程中，如果某个阶段超时或出错，则会重新开始四次挥手过程。同时，在 TCP 连接关闭过程中，可能存在 TIME_WAIT 状态，以避免网络延迟导致的重复请求。</p>
]]></content>
      <categories>
        <category>TCP 协议</category>
      </categories>
      <tags>
        <tag>TCP 协议</tag>
      </tags>
  </entry>
  <entry>
    <title>技术学习路线？</title>
    <url>/2020/01/01/%E6%80%9D%E8%80%83/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="学习与选择"><a href="#学习与选择" class="headerlink" title="学习与选择"></a>学习与选择</h2><pre><code>技术是第一生产力，兴趣决定动力，理论是一切基础；
</code></pre>
<span id="more"></span>

<h2 id="前端发展："><a href="#前端发展：" class="headerlink" title="前端发展："></a>前端发展：</h2><ul>
<li><p>前端路线</p>
<ul>
<li>深不可测，既能开发服务端，客户端，移动端，小程序，WEB；</li>
<li>前途无亮，领域广泛，全栈难度高，精通复杂；</li>
</ul>
</li>
<li><p>框架</p>
<ul>
<li><p>react：又更新不少新特性；</p>
</li>
<li><p>svelte：非常快；</p>
</li>
<li><p>vue：与 react 比较，该有的功能都有，还有些花里胡哨的功能；</p>
</li>
<li><p>Solid：观望；</p>
</li>
<li><p>Lit：观望；</p>
</li>
<li><p>angular，sea，require，jquery：加入淘汰系列，都被上面可代替；</p>
</li>
</ul>
</li>
<li><p>脚手架：</p>
<ul>
<li><p>webpack：模块打包器；</p>
</li>
<li><p>vite：对比 webpack 非常快；</p>
</li>
<li><p>nextjs、nuxtjs：ssr 脚手架；</p>
</li>
<li><p>remix：观望，router 作者开发的，非常优秀，功能还不够全，期待 2.0 发布；</p>
</li>
<li><p>astro：很优秀的静态网页 ssr 框架，可支持任何框架的集成开发；</p>
</li>
<li><p>esbuild：vite 背后的支持；</p>
</li>
<li><p>swc：Rust 封装前端脚手架；</p>
</li>
</ul>
</li>
</ul>
<h2 id="后端学习路线："><a href="#后端学习路线：" class="headerlink" title="后端学习路线："></a>后端学习路线：</h2><ul>
<li><p>语言及工具</p>
<ul>
<li>nodejs，nginx：首选推荐；</li>
<li>c，rust，python，c++，go，java，php，.net：基础学习，非必要；</li>
</ul>
</li>
<li><p>数据库</p>
<ul>
<li><p>mongo，redis： 首选推荐；</p>
</li>
<li><p>mysql：基础；</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>思考</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>🎉 Nodejs 诞生史</title>
    <url>/2014/05/01/%E5%90%8E%E7%AB%AF/Nodejs/Nodejs%20%E8%AF%9E%E7%94%9F%E5%8F%B2/</url>
    <content><![CDATA[<p><img src="/images/w3c.png"></p>
<p>🪴</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>2009 年，最初由 Ryan Dahl 于编写 Node.js。</p>
<p>Dahl 批评了 2009 年最流行的 Web 服务器 Apache HTTP Server 在处理大量并发连接（最多 10,000 个或更多）以及创建代码的最常见方式（顺序编程）方面的可能性有限，因为代码要么阻塞整个进程，要么在同时连接的情况下隐含多个执行堆栈。</p>
<p>Dahl 在 2009 年 11 月 8 日举行的首届欧洲 JSConf 上演示了该项目。 Node.js 结合了 Google 的 V8 JavaScript 引擎、事件循环和低级 I&#x2F;O API。</p>
<p>2010 年 01 月，为 Node.js 环境引入了一个名为 npm 的包管理器。包管理器使程序员可以更轻松地发布和共享 Node.js 包的源代码，并旨在简化包的安装、更新和卸载。</p>
<p>2011 年 06 月，微软和 Joyent 实现了 Node.js 的原生 Windows 版本。 第一个支持 Windows 的 Node.js 版本于 2011 年 7 月发布。</p>
<p>2012 年 01 月，Dahl 辞职，提拔同事兼 npm 创建者 Isaac Schlueter 来管理该项目。 2014 年 1 月，Schlueter 宣布 Timothy J. Fontaine 将领导该项目。</p>
<p>2014 年 12 月，Fedor Indutny 启动了 io.js，它是 Node.js 的一个分支。由于 Joyent 治理的内部冲突，io.js 被创建为一个开放的治理替代方案，并设有一个单独的技术委员会。与 Node.js 不同， 作者计划让 io.js 与最新版本的 Google V8 JavaScript 引擎保持同步。</p>
<p>2015 年 02 月，宣布了组建中立 Node.js 基金会的意图。到 2015 年 6 月，Node.js 和 io.js 社区投票决定在 Node.js 基金会下合作。</p>
<p>2015 年 09 月，Node.js v0.12 和 io.js v3.3 合并回 Node v4.0。这次合并将 V8 ES6 功能引入 Node.js 并形成长期支持发布周期。截至 2016 年，io.js 网站建议开发人员切换回 Node.js，并且由于合并而没有计划进一步发布 io.js。</p>
<p>2019 年 06 月，JS 基金会和 Node.js 基金会合并成立 OpenJS 基金会。</p>
<p>2023 年 03 月 15 日，Node.js 19.8.1 发布。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/Node.js">https://en.wikipedia.org/wiki/Node.js</a></p>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 诞生史</title>
    <url>/2014/05/01/%E5%89%8D%E7%AB%AF/JavaScript/JavaScript%20%E8%AF%9E%E7%94%9F%E5%8F%B2/</url>
    <content><![CDATA[<p><img src="/images/w3c.png"></p>
<p>🪴</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>1990 年底，欧洲核能研究组织（CERN）科学家 Tim Berners-Lee，在全世界最大的电脑网络——互联网的基础上，发明了万维网（World Wide Web），从此可以在网上浏览网页文件。</p>
<p>1992 年底，美国国家超级电脑应用中心（NCSA）开始开发一个独立的浏览器，叫做 Mosaic。这是人类历史上第一个浏览器。</p>
<p>1994 年 10 月，NCSA 的一个主要程序员 Marc Andreessen 联合风险投资家 Jim Clark，成立了 Mosaic 通信公司（Mosaic Communications），不久后改名为 Netscape。这家公司的方向，就是在 Mosaic 的基础上，开发面向普通用户的新一代的浏览器 Netscape Navigator。Netscape 公司很快发现，Navigator 浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为。当时，网速很慢而且上网费很贵，有些操作不宜在服务器端完成。</p>
<p>1995 年，Netscape 公司雇佣了程序员 Brendan Eich 开发这种网页脚本语言。Brendan Eich 有很强的函数式编程背景，希望以 Scheme 语言（函数式语言鼻祖 LISP 语言的一种方言）为蓝本，实现这种新语言。</p>
<p>1995 年 5 月，Brendan Eich 只用了 10 天，就设计完成了这种语言的第一版。它是一个大杂烩，语法有多个来源。</p>
<ul>
<li>基本语法：借鉴 C 语言和 Java 语言。</li>
<li>数据结构：借鉴 Java 语言，包括将值分成原始值和对象两大类。</li>
<li>函数的用法：借鉴 Scheme 语言和 Awk 语言，将函数当作第一等公民，并引入闭包。</li>
<li>原型继承模型：借鉴 Self 语言（Smalltalk 的一种变种）。</li>
<li>正则表达式：借鉴 Perl 语言。</li>
<li>字符串和数组处理：借鉴 Python 语言。</li>
</ul>
<p>Netscape 公司的这种浏览器脚本语言，最初名字叫做 Mocha，1995 年 9 月改为 LiveScript。12 月，Netscape 公司与 Sun 公司（Java 语言的发明者和所有者）达成协议，后者允许将这种语言叫做 JavaScript。</p>
<p>1996 年 11 月，Netscape 公司决定将 JavaScript 提交给国际标准化组织 ECMA（European Computer Manufacturers Association），希望 JavaScript 能够成为国际标准，以此抵抗微软 JScript。</p>
<p>1997 年 07 月，ECMA 组织发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript。</p>
<p>1997 年 07 月，ECMAScript 1.0 发布。</p>
<p>1999 年 12 月，ECMAScript 3.0 版发布。</p>
<p>2009 年 12 月，ECMAScript 5.0 版正式发布。</p>
<p>2015 年 06 月，ECMAScript 6.0 正式发布，并且更名为“ECMAScript 2015”。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://wangdoc.com/javascript/basic/history">https://wangdoc.com/javascript/basic/history</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>🎉 Python 诞生史</title>
    <url>/2014/05/01/%E5%90%8E%E7%AB%AF/Python/Python%20%E8%AF%9E%E7%94%9F%E5%8F%B2/</url>
    <content><![CDATA[<p><img src="/images/w3c.png"></p>
<p>🪴</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>Python 的作者，Guido von Rossum，确实是荷兰人。1982 年，Guido 从阿姆斯特丹大学获得了数学和计算机硕士学位。然而，尽管他算得上是一位数学家，但他更加享受计算机带来的乐趣。用他的话说，尽管拥有数学和计算机双料资质，他总趋向于做计算机相关的工作，并热衷于做任何和编程相关的活儿。</p>
<p>1991 年，第一个 Python 编译器诞生。它是用 C 语言实现的，并能够调用 C 语言的库文件。</p>
<p>2000 年 10 月，Python 2.0 发布。Python 2.7 的生命周期最初定于 2015 年，然后推迟到 2020 年。</p>
<p>2008 年 12 月，Python 3.0 发布。</p>
<p>2022 年 11 月，Python 3.11 是稳定版本。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/Redis">https://en.wikipedia.org/wiki/Redis</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>JS - 实现一个promiseAll？</title>
    <url>/2019/05/01/%E5%89%8D%E7%AB%AF/Promise/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromiseAll%EF%BC%9F/</url>
    <content><![CDATA[<!-- # JS - 实现一个 promiseAll？ -->

<p>代码示范：</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">promiseAll</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> len = promises.<span class="property">length</span>;</span><br><span class="line">        <span class="comment">// 请求等待结果</span></span><br><span class="line">        <span class="keyword">let</span> res = [];</span><br><span class="line">        <span class="comment">// 累计请求成功的数量</span></span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">index</span>) &#123;</span><br><span class="line">            promises[index]().<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">                res[index] = result;</span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (count === len) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_">resolve</span>(res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="title function_">next</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Promise</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>🎉 React - 生命周期？</title>
    <url>/2018/05/01/%E5%89%8D%E7%AB%AF/React/React%20-%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="当创建组件实例并将其插入到-DOM-中时，将按以下顺序调用这些方法："><a href="#当创建组件实例并将其插入到-DOM-中时，将按以下顺序调用这些方法：" class="headerlink" title="当创建组件实例并将其插入到 DOM 中时，将按以下顺序调用这些方法："></a>当创建组件实例并将其插入到 DOM 中时，将按以下顺序调用这些方法：</h2><ul>
<li>constructor(props)<ul>
<li>super(props);</li>
<li>初始化本地状态 this.state。</li>
<li>将事件处理程序方法绑定到实例。</li>
</ul>
</li>
<li>static getDerivedStateFromProps() 「很少使用」<ul>
<li>getDerivedStateFromProps(props, state) 在调用 render 方法之前调用，无论是在初始安装还是后续更新时。它应该返回一个对象来更新状态，或者 null 不更新任何内容。</li>
</ul>
</li>
<li>render()<ul>
<li>返回以下类型之一：JSX；片段；文本节点；布尔值 或 null 或 undefined。不渲染任何内容。</li>
</ul>
</li>
<li>componentDidMount()<ul>
<li>componentDidMount()在安装组件（插入树中）后立即调用。需要 DOM 节点的初始化应该放在此处。</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="更新中"><a href="#更新中" class="headerlink" title="更新中"></a>更新中</h2><h2 id="当组件被重新渲染时，这些方法将按以下顺序调用："><a href="#当组件被重新渲染时，这些方法将按以下顺序调用：" class="headerlink" title="当组件被重新渲染时，这些方法将按以下顺序调用："></a>当组件被重新渲染时，这些方法将按以下顺序调用：</h2><ul>
<li>static getDerivedStateFromProps()</li>
<li>shouldComponentUpdate() 「很少使用」<ul>
<li>用于 shouldComponentUpdate(nextProps, nextState) 让 React 知道组件的输出是否不受当前状态或属性变化的影响。默认行为是在每次状态更改时重新渲染，并且在绝大多数情况下您应该依赖默认行为。</li>
</ul>
</li>
<li>render()</li>
<li>getSnapshotBeforeUpdate()「很少使用」<ul>
<li>getSnapshotBeforeUpdate(prevProps, prevState) 在最近渲染的输出被提交到例如 DOM 之前调用。它使您的组件能够在 DOM 发生更改之前捕获一些信息（例如滚动位置）。此生命周期方法返回的任何值都将作为参数传递给 componentDidUpdate().</li>
</ul>
</li>
<li>componentDidUpdate()<ul>
<li>componentDidUpdate(prevProps, prevState, snapshot) 更新发生后立即调用。初始渲染不会调用此方法。</li>
</ul>
</li>
</ul>
<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><h2 id="当从-DOM-中删除组件时会调用此方法："><a href="#当从-DOM-中删除组件时会调用此方法：" class="headerlink" title="当从 DOM 中删除组件时会调用此方法："></a>当从 DOM 中删除组件时会调用此方法：</h2><ul>
<li>componentWillUnmount()<ul>
<li>componentWillUnmount()在组件被卸载和销毁之前立即调用。</li>
</ul>
</li>
</ul>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h2 id="当渲染期间、生命周期方法或任何子组件的构造函数中出现错误时，将调用这些方法。"><a href="#当渲染期间、生命周期方法或任何子组件的构造函数中出现错误时，将调用这些方法。" class="headerlink" title="当渲染期间、生命周期方法或任何子组件的构造函数中出现错误时，将调用这些方法。"></a>当渲染期间、生命周期方法或任何子组件的构造函数中出现错误时，将调用这些方法。</h2><ul>
<li>static getDerivedStateFromError(error)<ul>
<li>在后代组件抛出错误后调用此生命周期。它接收作为参数抛出的错误，并应返回一个值来更新状态。</li>
</ul>
</li>
<li>componentDidCatch(error, info)<ul>
<li>在后代组件抛出错误后调用此生命周期。它接收两个参数：</li>
<li>error- 抛出的错误。</li>
<li>info- 一个对象，其 componentStack 键包含有关哪个组件引发错误的信息。</li>
</ul>
</li>
</ul>
<h2 id="其他-API"><a href="#其他-API" class="headerlink" title="其他 API"></a>其他 API</h2><h2 id="每个组件还提供一些其他-API："><a href="#每个组件还提供一些其他-API：" class="headerlink" title="每个组件还提供一些其他 API："></a>每个组件还提供一些其他 API：</h2><ul>
<li>setState()<ul>
<li>setState(updater[, callback])</li>
<li>将组件状态的更改加入队列，并告诉 React 该组件及其子组件需要使用更新后的状态重新渲染。</li>
</ul>
</li>
<li>forceUpdate()<ul>
<li>component.forceUpdate(callback)</li>
<li>默认情况下，当组件的状态或属性发生更改时，组件将重新渲染。如果你的 render()方法依赖于一些其他数据，你可以通过调用 来告诉 React 该组件需要重新渲染 forceUpdate()。</li>
</ul>
</li>
</ul>
<p><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">生命周期图</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Ts - 如何使用枚举？</title>
    <url>/2022/02/01/%E5%89%8D%E7%AB%AF/Typescript/Ts%20-%20%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%EF%BC%9F/</url>
    <content><![CDATA[<p>在 TypeScript 中，你可以使用 enum 关键字来定义一个枚举类型。</p>
<p>代码示范：</p>
<span id="more"></span>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">enum <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Direction</span>.<span class="property">Up</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>🎉 Hexo 搭建和使用</title>
    <url>/2019/05/01/%E5%B7%A5%E5%85%B7/%F0%9F%8E%89%20Hexo%20%E6%90%AD%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h1><pre><code>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。

$ npm install -g hexo-cli
</code></pre>
<h1 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h1><pre><code>- themes 下载放置此处

- _config.yml
    - theme: landscape 设置主题
</code></pre>
<span id="more"></span>

<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><pre><code>https://hexo.io/zh-cn/docs/

https://hexo.io/themes/
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>🦀️ Git教程🔗</title>
    <url>/2018/05/01/%E5%B7%A5%E5%85%B7/%F0%9F%A6%80%EF%B8%8F%20Git%E6%95%99%E7%A8%8B%F0%9F%94%97/</url>
    <content><![CDATA[<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git 教程</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>🦀️ YAML 语言教程🔗</title>
    <url>/2018/05/01/%E5%B7%A5%E5%85%B7/%F0%9F%A6%80%EF%B8%8F%20YAML%20%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B%F0%9F%94%97/</url>
    <content><![CDATA[<p><a href="https://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML 语言教程</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>🦀️ curl 的用法指南🔗</title>
    <url>/2018/05/01/%E5%B7%A5%E5%85%B7/%F0%9F%A6%80%EF%B8%8F%20curl%20%E7%9A%84%E7%94%A8%E6%B3%95%E6%8C%87%E5%8D%97%F0%9F%94%97/</url>
    <content><![CDATA[<p><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl 的用法指南</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 入门</title>
    <url>/2018/05/01/%E5%B7%A5%E5%85%B7/%F0%9F%8E%89%20Git%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<ul>
<li><p>git config user.name [查看用户名]</p>
</li>
<li><p>git config user.email [邮箱地址]</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>git config –global user.name “username” [修改用户名]</p>
</li>
<li><p>git config user.name “username”[局部]</p>
</li>
<li><p>git config –global user.email “email” [邮箱地址]</p>
</li>
<li><p>git init [初始化]</p>
</li>
<li><p>git add [放入暂存区]</p>
</li>
<li><p>git status [状态]</p>
</li>
<li><p>git commit -m [提交并说明]</p>
</li>
<li><p>git diff [查看修改内容]</p>
</li>
<li><p>git reset –hard commit_id [回退和恢复版本分支]</p>
</li>
<li><p>git checkout – file [工作区的内容修改撤销]</p>
</li>
<li><p>rm || git rm [删除工作区||暂存区]</p>
</li>
</ul>
<h1 id="github"><a href="#github" class="headerlink" title="github"></a>github</h1><ul>
<li><p>ssh [密码]</p>
</li>
<li><p>git remote -v [远程库信息]</p>
</li>
<li><p>git remote add origin <a href="mailto:&#x67;&#x69;&#116;&#64;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#99;&#111;&#x6d;">&#x67;&#x69;&#116;&#64;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#99;&#111;&#x6d;</a>:somewhile&#x2F;systemjs.git [git 关联 github]</p>
</li>
<li><p>git branch –set-upstream-to&#x3D;origin name [关联远程分支]</p>
</li>
<li><p>git remote rm origin [删除关联]</p>
</li>
<li><p>git push -u origin master [推送]</p>
</li>
<li><p>git pull [更新]</p>
</li>
<li><p>git clone [克隆]</p>
</li>
<li><p>git stash [pull 冲突，本地暂时先存储起来，非常熟练及轻松项目可用，否则容易产生冲突]</p>
</li>
<li><p>git stash pop stash@{0}</p>
</li>
<li><p>git stash apply [恢复当前分支]</p>
</li>
</ul>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><ul>
<li><p>git checkout -b name 远程或本地 [创建分支]</p>
</li>
<li><p>git push origin [提交分支]</p>
</li>
<li><p>git branch [查看]</p>
</li>
<li><p>git checkout master [切换分支]</p>
</li>
<li><p>git merge dev [合并分支]</p>
</li>
<li><p>git branch -d||D dev [删除分支,不合并强制删除]</p>
</li>
<li><p>git push –set-upstream origin name [提交远程分支]</p>
</li>
<li><p>git push –delete origin name [删除远程分支]</p>
</li>
</ul>
<hr>
<ul>
<li>git 不能提交空文件夹</li>
</ul>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>🎉 Vi 命令</title>
    <url>/2016/05/01/%E7%B3%BB%E7%BB%9F/%F0%9F%8E%89%20vi%20%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="什么是-vi？"><a href="#什么是-vi？" class="headerlink" title="什么是 vi？"></a>什么是 vi？</h1><p>UNIX 操作系统自带的默认编辑器称为 vi（可视化编辑器）。[UNIX 环境的替代编辑器包括 pico 和 emacs，它是 GNU 的产品。]</p>
<span id="more"></span>

<ul>
<li>UNIX vi 编辑器是全屏编辑器，有两种操作模式：<ol>
<li>命令模式命令导致对文件采取操作，以及</li>
<li>插入模式，将输入的文本插入到文件中。</li>
</ol>
</li>
</ul>
<p>在命令模式下，输入的每个字符都是一个命令，对正在编辑的文本文件执行某些操作；在命令模式下键入的字符甚至可能导致 vi 编辑器进入插入模式。在插入模式下，输入的每个字符都会添加到文件中的文本中；按、&lt;Esc&gt; ( Escape ) 键可关闭插入模式。</p>
<p>虽然 vi 命令有很多，但对于 vi 初学者来说，通常只需要其中的一小部分就足够了。为了帮助此类用户，此网页包含基本 vi 命令的示例。下表中最基本和最有用的命令用星号（*或星号）标记。经过练习，这些命令应该变得自动。</p>
<p>注意： UNIX 和 vi 都区分大小写。确保不要使用大写字母代替小写字母；结果不会是你所期望的。</p>
<h1 id="进入和退出-vi"><a href="#进入和退出-vi" class="headerlink" title="进入和退出 vi"></a>进入和退出 vi</h1><h3 id="开始-vi"><a href="#开始-vi" class="headerlink" title="开始 vi"></a><code>开始 vi</code></h3><p>要对文件使用 vi ，请输入 vi filename。如果名为 filename 的文件存在，则显示该文件的第一页（或屏幕）；如果该文件不存在，则会创建一个空文件和屏幕，您可以在其中输入文本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*   vi 文件名   编辑从第 1 行开始的文件名</span><br><span class="line">    vi -r 文件名    恢复系统崩溃时正在编辑的文件名</span><br></pre></td></tr></table></figure>

<h3 id="退出-vi"><a href="#退出-vi" class="headerlink" title="退出 vi"></a><code>退出 vi</code></h3><p>通常，当您离开 vi 时，会保存新的或修改的文件。但是，也可以退出 vi 而不保存文件。</p>
<p>注意：每当键入冒号 (:) 时，光标就会移动到屏幕底部。此类命令可通过按&lt;Return&gt;（或&lt;Enter&gt;）键来完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*   :x  退出vi，将修改后的文件写入原始调用中指定的文件</span><br><span class="line">    :wq 退出vi，将修改后的文件写入原始调用中指定的文件</span><br><span class="line">    :q  退出（或退出）vi</span><br><span class="line">*   :q! 退出vi，即使尚未为此 vi 调用保存最新更改</span><br></pre></td></tr></table></figure>

<h1 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h1><p>与许多 PC 和 MacIntosh 编辑器不同，鼠标不会在 vi 编辑器屏幕（或窗口）内移动光标。您必须使用下面列出的键盘命令。在某些 UNIX 平台上，也可以使用方向键；然而，由于 vi 在设计时考虑了 Qwerty 键盘（不包含箭头键），因此箭头键有时会在 vi 中产生奇怪的效果，应避免使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*   j   或 &lt;回车&gt; [或向下箭头]  将光标向下移动一行</span><br><span class="line">*   k   [或向上箭头]    将光标向上移动一行</span><br><span class="line">*   h   或 &lt;空格&gt; [或左箭头]    将光标向左移动一个字符</span><br><span class="line">*   l   或 &lt;空格&gt; [或右箭头]    将光标向右移动一个字符</span><br><span class="line">*   o   将光标移动到当前行的开头（有光标的行）</span><br><span class="line">*   $   将光标移至当前行末尾</span><br><span class="line">    w	将光标移至下一个单词的开头</span><br><span class="line">    b	将光标移回前一个单词的开头</span><br><span class="line">    :0  &lt;回车&gt;或1G  将光标移动到文件的第一行</span><br><span class="line">    :n  &lt;回车&gt;或nG  将光标移至第 n行</span><br><span class="line">    :$  &lt;回车&gt;或G   将光标移动到文件的最后一行</span><br></pre></td></tr></table></figure>

<h1 id="添加、更改和删除文本"><a href="#添加、更改和删除文本" class="headerlink" title="添加、更改和删除文本"></a>添加、更改和删除文本</h1><p>以下命令允许您插入和添加文本。每个命令都会将 vi 编辑器置于插入模式；因此，必须按下<Esc>键来终止文本输入并将 vi 编辑器返回到命令模式。</p>
<h3 id="插入或添加文本"><a href="#插入或添加文本" class="headerlink" title="插入或添加文本"></a>插入或添加文本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*   i	在光标前插入文本，直到按下&lt;Esc&gt;</span><br><span class="line">    I	在当前行的开头插入文本，直到按下&lt;Esc&gt;</span><br><span class="line">*   a	在光标后追加文本，直到按下&lt;Esc&gt;</span><br><span class="line">    A	将文本附加到当前行末尾，直到按下&lt;Esc&gt;</span><br><span class="line">*   o	打开文本并将文本放入当前行下方的新行中，直到按下&lt;Esc&gt;</span><br><span class="line">*   O	打开文本并将文本放在当前行上方的新行中，直到按下&lt;Esc&gt;</span><br></pre></td></tr></table></figure>

<h3 id="更改文本"><a href="#更改文本" class="headerlink" title="更改文本"></a>更改文本</h3><p>以下命令允许您修改文本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*   r   替换光标下的单个字符（无需&lt;Esc&gt;）</span><br><span class="line">    R   替换字符，从当前光标位置开始，直到按下&lt;Esc&gt;</span><br><span class="line">    cw  从光标下的字符开始，用新文本更改当前单词 ，直到按下&lt;Esc&gt;</span><br><span class="line">    cNw 更改以光标下的字符开头的 N 个单词，直到按下&lt;Esc&gt;；例如，c5w 改变 5 个单词</span><br><span class="line">    C   更改（替换）当前行中的字符，直到按下&lt;Esc&gt;</span><br><span class="line">    cc  更改（替换）整个当前行，按下&lt;Esc&gt;时停止</span><br><span class="line">    Ncc or cNc 更改（替换）从当前行开始的接下来的 N 行， 当按下 &lt;Esc&gt; 时停止</span><br></pre></td></tr></table></figure>

<h3 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h3><p>以下命令允许您删除文本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*   X	删除光标下的单个字符</span><br><span class="line">    Nx	删除N个字符，从光标下的字符开始</span><br><span class="line">    dw	删除以光标所在字符开头的单个单词</span><br><span class="line">    dNw	删除以光标处字符开头的 N个单词；例如，d5w删除 5 个单词</span><br><span class="line">    D	从当前光标位置开始删除该行的其余部分</span><br><span class="line">*   DD	删除整个当前行</span><br><span class="line">    Ndd 或 dNd	删除N行，从当前行开始；例如，5dd删除 5 行</span><br></pre></td></tr></table></figure>

<h3 id="剪切和粘贴文本"><a href="#剪切和粘贴文本" class="headerlink" title="剪切和粘贴文本"></a>剪切和粘贴文本</h3><p>以下命令允许您复制和粘贴文本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*   yy	将当前行复制（复制、剪切）到缓冲区中</span><br><span class="line">    NYy 或 yNy	将接下来的 N 行（包括当前行）复制（复制、剪切）到缓冲区中</span><br><span class="line">    p	将缓冲区中的行放入（粘贴）到当前行之后的文本中</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cs.colostate.edu/helpdocs/vi.html">https://www.cs.colostate.edu/helpdocs/vi.html</a></p>
]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>🦀️ 搭建 babel 编译环境 🔗</title>
    <url>/2022/01/01/%E5%89%8D%E7%AB%AF/%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97/%F0%9F%A6%80%EF%B8%8F%20%E6%90%AD%E5%BB%BA%20babel%20%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%20%F0%9F%94%97/</url>
    <content><![CDATA[<p>俗话说：工欲善其事，必先利其器。学习 ES6 必不可少的一步就是搭建 babel 的编译环境，毕竟现在主流浏览器对 ES6 的很多语法和 API 支持不全面，还是需要 babel 转换成 ES5 的语法。</p>
<h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p><a href="https://mitianyi.gitbook.io/frontend-interview-guide/es6/build-babel-compiling-environment">搭建 babel 编译环境</a></p>
]]></content>
      <categories>
        <category>Babel</category>
      </categories>
      <tags>
        <tag>Babel</tag>
      </tags>
  </entry>
</search>
