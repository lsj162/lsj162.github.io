import{_ as e,c as o,o as s,a5 as t}from"./chunks/framework.-E9IboRH.js";const N=JSON.parse('{"title":"🔥👀Nodejs 中的事件循环？","description":"","frontmatter":{},"headers":[],"relativePath":"汇总面试题/后端Nodejs/专家题/🤔️Nodejs 中的事件循环？.md","filePath":"汇总面试题/后端Nodejs/专家题/🤔️Nodejs 中的事件循环？.md"}'),l={name:"汇总面试题/后端Nodejs/专家题/🤔️Nodejs 中的事件循环？.md"},a=t('<h1 id="🔥👀nodejs-中的事件循环" tabindex="-1">🔥👀Nodejs 中的事件循环？ <a class="header-anchor" href="#🔥👀nodejs-中的事件循环" aria-label="Permalink to &quot;🔥👀Nodejs 中的事件循环？&quot;">​</a></h1><p>Node.js 的事件循环（Event Loop）是实现异步非阻塞 I/O 操作的核心机制。</p><h2 id="其执行过程可以分为以下几个阶段" tabindex="-1">其执行过程可以分为以下几个阶段： <a class="header-anchor" href="#其执行过程可以分为以下几个阶段" aria-label="Permalink to &quot;其执行过程可以分为以下几个阶段：&quot;">​</a></h2><ol><li><p><strong>Timer 阶段</strong>：Timer 阶段负责处理到期的定时器。在这个阶段，Node.js 会检查所有已注册的定时器，执行到期的回调函数。</p></li><li><p><strong>I/O Callback 阶段</strong>：I/O Callback 阶段会执行一些系统 I/O 操作的回调函数，比如网络请求完成、文件读写完成等。这些回调函数是由系统底层触发的。</p></li><li><p><strong>Idle、Prepare 阶段</strong>：这是内部使用的阶段，不会执行 JavaScript 用户代码。</p></li><li><p><strong>Poll 阶段</strong>：在 Poll 阶段，Node.js 会处理除了定时器和系统 I/O 事件之外的所有事件，包括：</p><ul><li>如果 poll 队列不为空，则依次同步执行队列中的回调函数，直到队列为空或达到系统限制。</li><li>如果 poll 队列为空，并且设定了 <code>setImmediate()</code> 的回调函数，则跳转到 Check 阶段。</li><li>如果 poll 队列为空，且没有设定 <code>setImmediate()</code> 的回调函数，则 Node.js 将会等待新的事件触发，并且会在有新事件到来或者定时器到期时立即执行对应的回调函数。</li></ul></li><li><p><strong>Check 阶段</strong>：Check 阶段执行 <code>setImmediate()</code> 注册的回调函数。</p></li><li><p><strong>Close Callbacks 阶段</strong>：Close Callbacks 阶段执行一些关闭的回调函数，比如 <code>socket.on(&#39;close&#39;, ...)</code>。</p></li></ol><p>这个过程一直循环执行，直到没有事件待处理，或者显式调用 <code>process.exit()</code> 退出程序。</p><p>需要注意的是，虽然这些阶段顺序是固定的，但具体某个阶段是否执行取决于是否有相应的事件需要处理。此外，在事件循环的每个阶段都有机会执行微任务（Microtasks），包括 Promise 的回调函数和 <code>process.nextTick()</code> 注册的回调函数。这些微任务会在当前阶段执行完成后立即执行，然后再进入下一个阶段。</p>',6),d=[a];function r(c,i,n,_,p,m){return s(),o("div",null,d)}const j=e(l,[["render",r]]);export{N as __pageData,j as default};
