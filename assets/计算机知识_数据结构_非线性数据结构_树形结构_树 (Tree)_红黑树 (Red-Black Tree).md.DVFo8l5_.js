import{_ as e,c as r,o as t,a5 as o}from"./chunks/framework.DALfHeHd.js";const k=JSON.parse('{"title":"红黑树 (Red-Black Tree)","description":"","frontmatter":{},"headers":[],"relativePath":"计算机知识/数据结构/非线性数据结构/树形结构/树 (Tree)/红黑树 (Red-Black Tree).md","filePath":"计算机知识/数据结构/非线性数据结构/树形结构/树 (Tree)/红黑树 (Red-Black Tree).md","lastUpdated":1716891854000}'),l={name:"计算机知识/数据结构/非线性数据结构/树形结构/树 (Tree)/红黑树 (Red-Black Tree).md"},a=o('<h1 id="红黑树-red-black-tree" tabindex="-1">红黑树 (Red-Black Tree) <a class="header-anchor" href="#红黑树-red-black-tree" aria-label="Permalink to &quot;红黑树 (Red-Black Tree)&quot;">​</a></h1><p>红黑树（Red-Black Tree）是一种自平衡的二叉搜索树，它在插入和删除操作时通过旋转和重新着色来保持树的平衡，从而确保最坏情况下的时间复杂度为 O(log n)。红黑树是由 Rudolf Bayer 在 1972 年发明的，并由 Leo J. Guibas 和 Robert Sedgewick 在 1978 年进一步发展。</p><p>红黑树的平衡性是通过以下五个性质来保证的：</p><ol><li><strong>节点颜色</strong>：每个节点要么是红色，要么是黑色。</li><li><strong>根节点</strong>：根节点是黑色的。</li><li><strong>叶子节点</strong>：所有叶子节点（NIL 节点，空节点）都是黑色的。</li><li><strong>红色节点</strong>：如果一个节点是红色的，则它的两个子节点都是黑色的（从每个叶子到根的所有路径上不能有两个连续的红色节点）。</li><li><strong>黑色高度</strong>：从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li></ol><p>红黑树的这些性质确保了树的高度大致保持在 <code>log n</code> 的数量级，从而使得树的操作（如插入、删除和查找）的时间复杂度为 O(log n)。</p><p>红黑树的操作包括：</p><ul><li><strong>插入</strong>：在红黑树中插入一个新节点可能会破坏上述的性质，因此需要通过一系列的旋转和重新着色操作来恢复平衡。</li><li><strong>删除</strong>：删除操作同样可能破坏红黑树的性质，需要通过旋转和重新着色来恢复平衡。</li><li><strong>旋转</strong>：旋转是红黑树中的一种基本操作，包括左旋和右旋，用于调整树的结构而不破坏二叉搜索树的性质。</li><li><strong>重新着色</strong>：重新着色是另一种调整树平衡的方法，通过改变节点的颜色来满足红黑树的性质。</li></ul><p>红黑树在计算机科学中非常有用，特别是在需要频繁插入和删除操作的场景中，如关联数组、字典、集合等数据结构。由于其平衡性，红黑树在这些应用中提供了比普通二叉搜索树更好的性能保证。</p>',8),s=[a];function n(i,c,_,d,g,p){return t(),r("div",null,s)}const h=e(l,[["render",n]]);export{k as __pageData,h as default};
