import{_ as e,c as a,o as t,a5 as r}from"./chunks/framework.-E9IboRH.js";const R=JSON.parse('{"title":"什么是 React？React 的主要特性是什么？🚮","description":"","frontmatter":{},"headers":[],"relativePath":"汇总面试题/前端React/Ai热门面试题.md","filePath":"汇总面试题/前端React/Ai热门面试题.md"}'),o={name:"汇总面试题/前端React/Ai热门面试题.md"},c=r('<h1 id="什么是-react-react-的主要特性是什么-🚮" tabindex="-1">什么是 React？React 的主要特性是什么？🚮 <a class="header-anchor" href="#什么是-react-react-的主要特性是什么-🚮" aria-label="Permalink to &quot;什么是 React？React 的主要特性是什么？🚮&quot;">​</a></h1><p>React 是由 Facebook 开发单页面应用程序（Single Page Applications - SPAs）JavaScript 库。特点组件化，虚拟 DOM，单向数据流，JSX，生命周期方法。</p><h1 id="react-中的-jsx-是什么" tabindex="-1">React 中的 JSX 是什么？ <a class="header-anchor" href="#react-中的-jsx-是什么" aria-label="Permalink to &quot;React 中的 JSX 是什么？&quot;">​</a></h1><p>JSX（JavaScript XML）是一种 JavaScript 的语法扩展，用于在 React 中描述用户界面的结构。特点：标记语法，JavaScript 表达式，组件，属性，防止注入攻击。</p><h1 id="虚拟-dom-是什么-以及它的作用是什么" tabindex="-1">虚拟 DOM 是什么，以及它的作用是什么？ <a class="header-anchor" href="#虚拟-dom-是什么-以及它的作用是什么" aria-label="Permalink to &quot;虚拟 DOM 是什么，以及它的作用是什么？&quot;">​</a></h1><p>虚拟 DOM，是一个虚拟的内存中的表示，以树形结构表示整个 DOM 树。工作流：状态变更，虚拟 DOM 重建，差异比较，更新实际 DOM。作用：性能提升，跨平台兼容性，简化复杂性。</p><h1 id="react-组件有哪两种类型-🚮" tabindex="-1">React 组件有哪两种类型？🚮 <a class="header-anchor" href="#react-组件有哪两种类型-🚮" aria-label="Permalink to &quot;React 组件有哪两种类型？🚮&quot;">​</a></h1><p>在 React 中，组件分为两种主要类型：函数组件和类组件。</p><h1 id="解释-react-的单向数据流-🚮" tabindex="-1">解释 React 的单向数据流？🚮 <a class="header-anchor" href="#解释-react-的单向数据流-🚮" aria-label="Permalink to &quot;解释 React 的单向数据流？🚮&quot;">​</a></h1><p>React 中的单向数据流是指数据在整个应用程序中的流动方向是单向的，不是直接在子组件中修改父组件的数据。这种设计模式有助于应用程序的可维护性、可预测性和调试性。</p><h1 id="什么是状态-state-和属性-props-它们之间有什么区别-🚮" tabindex="-1">什么是状态（state）和属性（props）？它们之间有什么区别？🚮 <a class="header-anchor" href="#什么是状态-state-和属性-props-它们之间有什么区别-🚮" aria-label="Permalink to &quot;什么是状态（state）和属性（props）？它们之间有什么区别？🚮&quot;">​</a></h1><p>区别：状态是局部的，可变的，而属性是传递的，不可变的。</p><h1 id="解释-react-中的-hoc-高阶组件-higher-order-components-🚮" tabindex="-1">解释 React 中的 HOC 高阶组件（Higher Order Components）？🚮 <a class="header-anchor" href="#解释-react-中的-hoc-高阶组件-higher-order-components-🚮" aria-label="Permalink to &quot;解释 React 中的 HOC 高阶组件（Higher Order Components）？🚮&quot;">​</a></h1><p>高阶组件（Higher Order Component，HOC）是一种用于重复使用组件逻辑的 React 组件模式。</p><h1 id="什么是-react-的上下文-context" tabindex="-1">什么是 React 的上下文（Context）？ <a class="header-anchor" href="#什么是-react-的上下文-context" aria-label="Permalink to &quot;什么是 React 的上下文（Context）？&quot;">​</a></h1><p>React 的上下文（Context）是一种在组件树中共享数据的机制，用于避免通过 props 一层层传递数据。 什么是 Redux，以及为什么使用它？</p><h1 id="什么是纯组件-pure-component" tabindex="-1">什么是纯组件（Pure Component）？ <a class="header-anchor" href="#什么是纯组件-pure-component" aria-label="Permalink to &quot;什么是纯组件（Pure Component）？&quot;">​</a></h1><p>React.PureComponent，shouldComponentUpdate 会浅比较组件的 props 和 state 对象。无变化，纯组件就会阻止重新渲染，以提高性能。</p><h1 id="react-中的-key-属性的作用是什么" tabindex="-1">React 中的“key”属性的作用是什么？ <a class="header-anchor" href="#react-中的-key-属性的作用是什么" aria-label="Permalink to &quot;React 中的“key”属性的作用是什么？&quot;">​</a></h1><p>识别哪些元素发生了变化，作用：唯一标识，优化列表更新，保持组件状态。</p><h1 id="解释-react-中的事件合成-event-handling-in-react-。" tabindex="-1">解释 React 中的事件合成（Event Handling in React）。 <a class="header-anchor" href="#解释-react-中的事件合成-event-handling-in-react-。" aria-label="Permalink to &quot;解释 React 中的事件合成（Event Handling in React）。&quot;">​</a></h1><p>是 React 提供的一种封装浏览器原生事件的机制。事件委托，无需手动绑定 this，合成事件池，跨浏览器兼容性。</p><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h1><h1 id="react-中的受控组件和非受控组件有什么区别" tabindex="-1">React 中的受控组件和非受控组件有什么区别？ <a class="header-anchor" href="#react-中的受控组件和非受控组件有什么区别" aria-label="Permalink to &quot;React 中的受控组件和非受控组件有什么区别？&quot;">​</a></h1><p>受控组件是指表单元素的值，由 React 组件的 state 控制的组件。非受控组件是由 DOM 本身来管理。在非受控组件中，通常使用 ref 来获取 DOM 元素的引用，并直接访问或修改 DOM 元素的值。</p><h1 id="react-中的-usecallback-和-usememo-有何异同" tabindex="-1">React 中的 useCallback 和 useMemo 有何异同？ <a class="header-anchor" href="#react-中的-usecallback-和-usememo-有何异同" aria-label="Permalink to &quot;React 中的 useCallback 和 useMemo 有何异同？&quot;">​</a></h1><p>useCallback 缓存的是回调函数，适用于避免在每次渲染时都创建新的回调函数。 useMemo 缓存的是计算结果，适用于避免在每次渲染时都重新计算。</p><h1 id="react-中的-usereducer-和-usestate-有何不同" tabindex="-1">React 中的“useReducer”和“useState”有何不同？ <a class="header-anchor" href="#react-中的-usereducer-和-usestate-有何不同" aria-label="Permalink to &quot;React 中的“useReducer”和“useState”有何不同？&quot;">​</a></h1><p>useState 是 React 提供的最基本的状态管理 Hook。useReducer 它允许你管理复杂的状态逻辑，尤其适用于处理具有多个状态转换的场景。</p><h1 id="react-中的-uselayouteffect-和-useeffect-的区别是什么" tabindex="-1">React 中的“useLayoutEffect”和“useEffect”的区别是什么？ <a class="header-anchor" href="#react-中的-uselayouteffect-和-useeffect-的区别是什么" aria-label="Permalink to &quot;React 中的“useLayoutEffect”和“useEffect”的区别是什么？&quot;">​</a></h1><p>useLayoutEffect 会在浏览器布局和绘制之后、组件渲染完成前执行。它会在浏览器执行绘制之前同步执行，因此可能会阻塞页面的渲染。 useEffect 是在浏览器渲染完成后执行的，不会阻塞浏览器的布局和绘制操作。</p><h1 id="react-中的-memo-和-purecomponent-有何不同" tabindex="-1">React 中的“memo”和“PureComponent”有何不同？ <a class="header-anchor" href="#react-中的-memo-和-purecomponent-有何不同" aria-label="Permalink to &quot;React 中的“memo”和“PureComponent”有何不同？&quot;">​</a></h1><p>React.memo 是一个高阶组件，PureComponent 是一个类。PureComponent 对 props 和 state 进行浅层比较，React.memo 对 props 进行浅层比较。React.memo 适用于函数组件，PureComponent 适用于类组件。</p><h1 id="react-中的懒加载-lazy-loading-和代码分割-code-splitting-和预加载-preloading-是什么" tabindex="-1">React 中的懒加载（Lazy Loading）和代码分割（Code Splitting）和预加载（Preloading）是什么？ <a class="header-anchor" href="#react-中的懒加载-lazy-loading-和代码分割-code-splitting-和预加载-preloading-是什么" aria-label="Permalink to &quot;React 中的懒加载（Lazy Loading）和代码分割（Code Splitting）和预加载（Preloading）是什么？&quot;">​</a></h1><p>懒加载允许在组件真正需要时再进行加载。代码分割是一种将代码拆分成多个小块的技术。预加载是在页面初始加载时提前加载一些资源。</p><h1 id="react-中的-react-lazy-和-import-有何关系" tabindex="-1">React 中的“React.lazy”和“import()”有何关系？ <a class="header-anchor" href="#react-中的-react-lazy-和-import-有何关系" aria-label="Permalink to &quot;React 中的“React.lazy”和“import()”有何关系？&quot;">​</a></h1><p>React.lazy 本质上是基于 import() 实现的。</p>',37),n=[c];function i(l,s,h,p,d,u){return t(),a("div",null,n)}const f=e(o,[["render",i]]);export{R as __pageData,f as default};
