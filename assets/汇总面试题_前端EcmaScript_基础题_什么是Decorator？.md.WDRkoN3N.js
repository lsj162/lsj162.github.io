import{_ as s,c as a,o as i,a5 as n}from"./chunks/framework.-E9IboRH.js";const g=JSON.parse('{"title":"基础题：ES6：什么是 Decorator？","description":"","frontmatter":{},"headers":[],"relativePath":"汇总面试题/前端EcmaScript/基础题/什么是Decorator？.md","filePath":"汇总面试题/前端EcmaScript/基础题/什么是Decorator？.md"}'),t={name:"汇总面试题/前端EcmaScript/基础题/什么是Decorator？.md"},p=n(`<h1 id="基础题-es6-什么是-decorator" tabindex="-1">基础题：ES6：什么是 Decorator？ <a class="header-anchor" href="#基础题-es6-什么是-decorator" aria-label="Permalink to &quot;基础题：ES6：什么是 Decorator？&quot;">​</a></h1><p>Decorator 装饰器，装饰者模式就是一种在不改变原类和使用继承的情况下，动态地扩展对象功能的设计理论。</p><p>在 ES6 及后续版本中，装饰器是一种用于修改或扩展类、方法、属性等的语法特性。装饰器提供了一种简洁、可读性强的方式来处理类和类成员的元数据以及行为。</p><p>装饰器的使用通过在目标对象（如类、方法、属性等）前面添加<code>@</code>符号来实现。装饰器可以是函数，被调用时接收被装饰的目标对象作为参数，并返回一个新的目标对象或进行修改。</p><p>在 JavaScript 中，装饰器主要用于以下几个方面：</p><ol><li><p><strong>类装饰器：</strong> 用于修改或扩展整个类。类装饰器接收目标类作为参数。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@decorator</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 类的定义</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>方法装饰器：</strong> 用于修改或扩展类的方法。方法装饰器接收目标类的原型、方法名称和属性描述符作为参数。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  @decorator</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  myMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 方法的定义</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>属性装饰器：</strong> 用于修改或扩展类的属性。属性装饰器接收目标类的原型和属性名称作为参数。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  @decorator</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  myProperty</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 42</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>参数装饰器：</strong> 用于修改或扩展类的构造函数参数。参数装饰器接收目标类的原型、方法名称和参数索引作为参数。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  myMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@decorator </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">param</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 方法的定义</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ol><p>尽管装饰器的提案已经被加入 ECMAScript 标准，但它目前仍处于实验阶段，并未被所有 JavaScript 环境广泛支持。在实际项目中使用装饰器时，需要注意环境的兼容性，并可能需要使用工具（如 Babel）进行转译。</p>`,7),l=[p];function e(h,r,k,c,o,d){return i(),a("div",null,l)}const y=s(t,[["render",e]]);export{g as __pageData,y as default};
