import{_ as i,c as a,o as t,a6 as s}from"./chunks/framework.DwCPU-X7.js";const g=JSON.parse('{"title":"浏览器的组成","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"前端/HTML/浏览器模型/浏览器环境概述.md","filePath":"前端/HTML/浏览器模型/浏览器环境概述.md","lastUpdated":null}'),l={name:"前端/HTML/浏览器模型/浏览器环境概述.md"},e=s(`<h1 id="浏览器的组成" tabindex="-1">浏览器的组成 <a class="header-anchor" href="#浏览器的组成" aria-label="Permalink to &quot;浏览器的组成&quot;">​</a></h1><p>浏览器的核心是两部分：渲染引擎和 JavaScript 解释器（又称 JavaScript 引擎）。</p><h2 id="渲染引擎" tabindex="-1">渲染引擎 <a class="header-anchor" href="#渲染引擎" aria-label="Permalink to &quot;渲染引擎&quot;">​</a></h2><p>不同的浏览器有不同的渲染引擎。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Firefox：Gecko 引擎，Safari：WebKit 引擎，Chrome：Blink 引擎，IE: Trident 引擎，Edge: EdgeHTML 引擎</span></span></code></pre></div><p>渲染过程四个阶段。</p><ol><li>解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。</li><li>对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。</li><li>布局：计算出渲染树的布局（layout）。</li><li>绘制：将渲染树绘制到屏幕。</li></ol><p>以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的 HTML 代码还没下载完，但浏览器已经显示出内容了。</p><h2 id="重绘和回流" tabindex="-1">重绘和回流 <a class="header-anchor" href="#重绘和回流" aria-label="Permalink to &quot;重绘和回流&quot;">​</a></h2><p>渲染树转换为布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。</p><p>页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）。再比如，重绘 table 布局和 flex 布局，开销都会比较大。</p><p>优化：</p><ul><li>读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。</li><li>缓存 DOM 信息。</li><li>一次性改变样式。</li><li>使用 documentFragment 操作 DOM</li><li>动画使用 absolute 定位或 fixed 定位，这样可以减少对其他元素的影响。</li><li>只在必要时才显示隐藏元素。</li><li>使用 window.requestAnimationFrame()，因为它可以把代码推迟到下一次重绘之前执行，而不是立即要求页面重绘。</li><li>使用虚拟 DOM（virtual DOM）库。</li></ul><h2 id="javascript-引擎" tabindex="-1">JavaScript 引擎 <a class="header-anchor" href="#javascript-引擎" aria-label="Permalink to &quot;JavaScript 引擎&quot;">​</a></h2><p>早期，JavaScript 处理过程如下：</p><ul><li>读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。</li><li>对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。</li><li>使用“翻译器”（translator），将代码转为字节码（bytecode）。</li><li>使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。</li></ul><p>现代浏览器改为采用“即时编译”（Just In Time compiler，缩写 JIT），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache）。</p><p>字节码不能直接运行，而是运行在一个虚拟机（Virtual Machine）之上，一般也把虚拟机称为 JavaScript 引擎。</p><h2 id="网页中嵌入-javascript-代码-主要有四种方法。" tabindex="-1">网页中嵌入 JavaScript 代码，主要有四种方法。 <a class="header-anchor" href="#网页中嵌入-javascript-代码-主要有四种方法。" aria-label="Permalink to &quot;网页中嵌入 JavaScript 代码，主要有四种方法。&quot;">​</a></h2><ul><li>&lt;script&gt; 元素直接嵌入代码。</li><li>&lt;script&gt; 标签加载外部脚本</li><li>事件属性</li><li>URL 协议</li></ul><h2 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h2><p>浏览器加载 JavaScript 脚本，主要通过&lt;script&gt;元素完成。正常的网页加载流程是这样的。</p><ol><li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li><li>解析过程中，浏览器发现&lt;script&gt;元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</li><li>如果&lt;script&gt;元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li><li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li></ol><h2 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to &quot;优化&quot;">​</a></h2><ol><li><p>defer 属性</p><p>继续完成解析 HTML 后，执行下载好的 js。</p></li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;a.js&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;b.js&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><ol start="2"><li><p>async 属性</p><p>继续往下解析 HTML，js 下载完成，立即执行，继续解析 html。</p></li></ol><div class="tip custom-block"><p class="custom-block-title">提示</p><p>同时使用 async 和 defer 属性，浏览器行为由 async 属性决定。</p></div><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><p><a href="https://wangdoc.com/javascript/bom/engine#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5" target="_blank" rel="noreferrer">https://wangdoc.com/javascript/bom/engine#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5</a></p>`,30),p=[e];function r(n,h,o,c,d,k){return t(),a("div",null,p)}const E=i(l,[["render",r]]);export{g as __pageData,E as default};
