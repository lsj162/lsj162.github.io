import{_ as e,c as r,o as a,a5 as t}from"./chunks/framework.-E9IboRH.js";const d=JSON.parse('{"title":"基础题：什么是 fiber 架构？","description":"","frontmatter":{},"headers":[],"relativePath":"汇总面试题/前端React/基础题/基础题：什么是 fiber 架构？.md","filePath":"汇总面试题/前端React/基础题/基础题：什么是 fiber 架构？.md"}'),i={name:"汇总面试题/前端React/基础题/基础题：什么是 fiber 架构？.md"},o=t('<h1 id="基础题-什么是-fiber-架构" tabindex="-1">基础题：什么是 fiber 架构？ <a class="header-anchor" href="#基础题-什么是-fiber-架构" aria-label="Permalink to &quot;基础题：什么是 fiber 架构？&quot;">​</a></h1><h2 id="fiber-解决了" tabindex="-1">fiber 解决了： <a class="header-anchor" href="#fiber-解决了" aria-label="Permalink to &quot;fiber 解决了：&quot;">​</a></h2><p>react fiber 就是為了解決這些問題而誕生的架構。自定义手动操作调用堆栈。</p><p>出自於 CPU 的瓶頸（元件層級深且複雜、耗性能的運算、設備本身 CPU 性能不足…等等）與 IO 的瓶頸（網路請求）</p><h2 id="fiber-原理" tabindex="-1">fiber 原理： <a class="header-anchor" href="#fiber-原理" aria-label="Permalink to &quot;fiber 原理：&quot;">​</a></h2><p>fiber 可以將頁面渲染的任務切分成 chunks 单元。 为不同类型的工作分配优先级（prioritize 方法）。 暂停 work，稍后再回来。 重用以前完成的 work。 如果不再需要则中止 work。</p><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><p>可以到以下兩個版本的範例網站看看差別：</p><p><a href="https://claudiopro.github.io/react-fiber-vs-stack-demo/stack.html" target="_blank" rel="noreferrer">旧版（without fiber）</a></p><p><a href="https://claudiopro.github.io/react-fiber-vs-stack-demo/fiber.html" target="_blank" rel="noreferrer">新版（with fiber）</a></p><p><a href="https://medium.com/starbugs/react-%E9%96%8B%E7%99%BC%E8%80%85%E4%B8%80%E5%AE%9A%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%BA%95%E5%B1%A4%E6%9E%B6%E6%A7%8B-react-fiber-c3ccd3b047a1" target="_blank" rel="noreferrer">React 開發者一定要知道的底層機制 — React Fiber Reconciler</a></p><p><a href="https://github.com/acdlite/react-fiber-architecture" target="_blank" rel="noreferrer">关于 React 新核心算法 React Fiber 的描述</a></p>',12),c=[o];function f(b,h,_,s,n,l){return a(),r("div",null,c)}const u=e(i,[["render",f]]);export{d as __pageData,u as default};
