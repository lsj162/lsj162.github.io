import{_ as s,c as i,o as a,a5 as n}from"./chunks/framework.DALfHeHd.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"计算机知识/数据结构/线性结构/链表 (Linked List)/双向链表 (Doubly Linked List).md","filePath":"计算机知识/数据结构/线性结构/链表 (Linked List)/双向链表 (Doubly Linked List).md","lastUpdated":1717313630000}'),t={name:"计算机知识/数据结构/线性结构/链表 (Linked List)/双向链表 (Doubly Linked List).md"},l=n(`<p>双向链表（Doubly Linked List）是一种链式存储结构，与单链表类似，双向链表的每个节点包含数据域和两个指针域，但不同之处在于双向链表的节点有两个指针域：一个指向前一个节点（prev 指针），另一个指向后一个节点（next 指针）。这种结构使得双向链表的节点可以在两个方向上遍历。</p><p>双向链表的特点：</p><ol><li><strong>双向性</strong>：在双向链表中，每个节点有两个指针，一个指向下一个节点（next），另一个指向前一个节点（prev）。这意味着可以从任意一个节点开始向前或向后遍历整个链表。</li><li><strong>灵活性</strong>：双向链表可以很方便地在任一节点之后插入或删除节点，而单链表只能从头节点开始进行操作。</li><li><strong>内存占用</strong>：双向链表每个节点比单链表多一个指针，所以在空间利用率上相对较低。</li></ol><p>双向链表的基本操作包括：</p><ul><li><strong>插入节点</strong>：在双向链表中插入一个节点需要同时更新其前一个和后一个节点的指针。</li><li><strong>删除节点</strong>：删除双向链表中的节点需要更新其前后节点的指针。</li><li><strong>遍历</strong>：双向链表可以从头节点开始向前或向后遍历整个链表。</li></ul><p>双向链表的实现：</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DoublyLinkedList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> __init__</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self):</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> None</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    def</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(self, data):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.head:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">            self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Node(data, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        last </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> self</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.head</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> last.next:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            last </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> last.next</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        last.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Node(data, last, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>双向链表广泛应用于很多算法和数据结构中，如 LRU 缓存、双向队列（deque）等。在需要双向遍历的场景中，双向链表是一个非常有用的工具。与单链表相比，虽然双向链表在内存使用上有一定劣势，但由于其在双向遍历上的便利性，它仍然在很多场景下具有其独特的优势。</p>`,8),p=[l];function h(e,k,d,r,E,g){return a(),i("div",null,p)}const c=s(t,[["render",h]]);export{y as __pageData,c as default};
