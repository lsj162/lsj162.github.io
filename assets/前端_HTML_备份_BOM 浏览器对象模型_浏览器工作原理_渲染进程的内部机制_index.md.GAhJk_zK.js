import{_ as l,c as i,o as e,a5 as a}from"./chunks/framework.-E9IboRH.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端/HTML/备份/BOM 浏览器对象模型/浏览器工作原理/渲染进程的内部机制/index.md","filePath":"前端/HTML/备份/BOM 浏览器对象模型/浏览器工作原理/渲染进程的内部机制/index.md"}'),t={name:"前端/HTML/备份/BOM 浏览器对象模型/浏览器工作原理/渲染进程的内部机制/index.md"},r=a('<h2 id="工作流程" tabindex="-1">工作流程 <a class="header-anchor" href="#工作流程" aria-label="Permalink to &quot;工作流程&quot;">​</a></h2><p>下面是渲染引擎在获取文档内容之后的大致工作流程：</p><ul><li>Parsing：解析文档 <ul><li>构建文档对象模型</li><li>构建样式对象模型</li><li>脚本异步加载</li></ul></li><li>RenderTree：构建渲染 <ul><li>遍历文档树</li></ul></li><li>Style Calculation：样式计算</li><li>Layout：布局</li><li>Paint：绘制</li><li>Rasterization：光栅化</li><li>Composite：合并</li></ul><ol><li>浏览器解析过程</li></ol><ul><li>HTML / SVG / XHTML：渲染引擎通过三个 C++ 的类对应这三类文档，解析这三类文件并构建 DOM 树（DOM Tree）</li><li>CSS：渲染引擎解析外部 CSS 文件及内联 style 标签内的样式数据，并构建 CSS 规则树（ CSS Rule Tree） JavaScript：JavaScript 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree</li></ul><ol start="2"><li>构建渲染树（Rendering Tree） <ul><li>解析完成后，浏览器引擎会通过 DOM 树和 CSS 规则树来构造 渲染树</li><li>渲染树并不等同于 DOM 树，因为一些像 &lt;header&gt; 或 display: none 的东西就没必要放到渲染树中</li><li>CSS 的 Rule Tree 主要是为了完成匹配并把 CSS Rule 附加至渲染树上的每个 Element 上。然后，计算每个渲染对象的位置，这通常是 布局（Layout） 和 重排（Reflow） 过程中发生</li><li>一旦渲染树构建完成，浏览器会把树里面的内容绘制在屏幕上。</li></ul></li><li>布局（Layout）：渲染树构建好之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标</li><li>绘制（Paint）：再下一步就是绘制，即遍历渲染树，并使用渲染引擎绘制每个节点</li><li>渲染层合并（Composite）：页面中 DOM 元素的绘制是在多个层上进行的，在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后在屏幕上呈现</li><li>最后通过调用操作系统 NativeGUI API 进行绘制</li></ol><h2 id="脚本异步加载" tabindex="-1">脚本异步加载 <a class="header-anchor" href="#脚本异步加载" aria-label="Permalink to &quot;脚本异步加载&quot;">​</a></h2><p>现代浏览器总是并行加载资源。脚本文件互相不会阻塞，但是会阻塞其他资源（例如图片、字体等）的下载。</p><p>后来为了用户体验，有了 async 和 defer ，脚本标记为异步，不会阻塞其他线程解析和执行。</p><h3 id="异步加载" tabindex="-1">异步加载 <a class="header-anchor" href="#异步加载" aria-label="Permalink to &quot;异步加载&quot;">​</a></h3><ul><li>标注为 defer 的 JavaScript 脚本文件不会停止 HTML 文档解析，而是等到解析结束才执行</li><li>标注为 async 只能引用外部脚本，下载完马上执行，但是不能保证加载顺序。</li></ul>',11),o=[r];function n(s,d,c,u,S,_){return e(),i("div",null,o)}const T=l(t,[["render",n]]);export{h as __pageData,T as default};
